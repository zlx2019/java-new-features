// Generated by jextract

package com.zero.panama.generate.unix;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class unistd_h {

    unistd_h() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int __has_safe_buffers = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __has_safe_buffers 0
     * }
     */
    public static int __has_safe_buffers() {
        return __has_safe_buffers;
    }
    private static final int __DARWIN_ONLY_64_BIT_INO_T = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_64_BIT_INO_T 0
     * }
     */
    public static int __DARWIN_ONLY_64_BIT_INO_T() {
        return __DARWIN_ONLY_64_BIT_INO_T;
    }
    private static final int __DARWIN_ONLY_UNIX_CONFORMANCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_UNIX_CONFORMANCE 1
     * }
     */
    public static int __DARWIN_ONLY_UNIX_CONFORMANCE() {
        return __DARWIN_ONLY_UNIX_CONFORMANCE;
    }
    private static final int __DARWIN_ONLY_VERS_1050 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_VERS_1050 0
     * }
     */
    public static int __DARWIN_ONLY_VERS_1050() {
        return __DARWIN_ONLY_VERS_1050;
    }
    private static final int __DARWIN_UNIX03 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_UNIX03 1
     * }
     */
    public static int __DARWIN_UNIX03() {
        return __DARWIN_UNIX03;
    }
    private static final int __DARWIN_64_BIT_INO_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_64_BIT_INO_T 1
     * }
     */
    public static int __DARWIN_64_BIT_INO_T() {
        return __DARWIN_64_BIT_INO_T;
    }
    private static final int __DARWIN_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_VERS_1050 1
     * }
     */
    public static int __DARWIN_VERS_1050() {
        return __DARWIN_VERS_1050;
    }
    private static final int __DARWIN_NON_CANCELABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NON_CANCELABLE 0
     * }
     */
    public static int __DARWIN_NON_CANCELABLE() {
        return __DARWIN_NON_CANCELABLE;
    }
    private static final int __STDC_WANT_LIB_EXT1__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_WANT_LIB_EXT1__ 1
     * }
     */
    public static int __STDC_WANT_LIB_EXT1__() {
        return __STDC_WANT_LIB_EXT1__;
    }
    private static final int __DARWIN_NO_LONG_LONG = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NO_LONG_LONG 0
     * }
     */
    public static int __DARWIN_NO_LONG_LONG() {
        return __DARWIN_NO_LONG_LONG;
    }
    private static final int _DARWIN_FEATURE_64_BIT_INODE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_64_BIT_INODE 1
     * }
     */
    public static int _DARWIN_FEATURE_64_BIT_INODE() {
        return _DARWIN_FEATURE_64_BIT_INODE;
    }
    private static final int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE() {
        return _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE;
    }
    private static final int _DARWIN_FEATURE_UNIX_CONFORMANCE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_UNIX_CONFORMANCE 3
     * }
     */
    public static int _DARWIN_FEATURE_UNIX_CONFORMANCE() {
        return _DARWIN_FEATURE_UNIX_CONFORMANCE;
    }
    private static final int __has_ptrcheck = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __has_ptrcheck 0
     * }
     */
    public static int __has_ptrcheck() {
        return __has_ptrcheck;
    }
    private static final int USE_CLANG_TYPES = (int)0L;
    /**
     * {@snippet lang=c :
     * #define USE_CLANG_TYPES 0
     * }
     */
    public static int USE_CLANG_TYPES() {
        return USE_CLANG_TYPES;
    }
    private static final int __PTHREAD_SIZE__ = (int)8176L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_SIZE__ 8176
     * }
     */
    public static int __PTHREAD_SIZE__() {
        return __PTHREAD_SIZE__;
    }
    private static final int __PTHREAD_ATTR_SIZE__ = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_ATTR_SIZE__ 56
     * }
     */
    public static int __PTHREAD_ATTR_SIZE__() {
        return __PTHREAD_ATTR_SIZE__;
    }
    private static final int __PTHREAD_MUTEXATTR_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEXATTR_SIZE__ 8
     * }
     */
    public static int __PTHREAD_MUTEXATTR_SIZE__() {
        return __PTHREAD_MUTEXATTR_SIZE__;
    }
    private static final int __PTHREAD_MUTEX_SIZE__ = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_SIZE__ 56
     * }
     */
    public static int __PTHREAD_MUTEX_SIZE__() {
        return __PTHREAD_MUTEX_SIZE__;
    }
    private static final int __PTHREAD_CONDATTR_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_CONDATTR_SIZE__ 8
     * }
     */
    public static int __PTHREAD_CONDATTR_SIZE__() {
        return __PTHREAD_CONDATTR_SIZE__;
    }
    private static final int __PTHREAD_COND_SIZE__ = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_COND_SIZE__ 40
     * }
     */
    public static int __PTHREAD_COND_SIZE__() {
        return __PTHREAD_COND_SIZE__;
    }
    private static final int __PTHREAD_ONCE_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_ONCE_SIZE__ 8
     * }
     */
    public static int __PTHREAD_ONCE_SIZE__() {
        return __PTHREAD_ONCE_SIZE__;
    }
    private static final int __PTHREAD_RWLOCK_SIZE__ = (int)192L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCK_SIZE__ 192
     * }
     */
    public static int __PTHREAD_RWLOCK_SIZE__() {
        return __PTHREAD_RWLOCK_SIZE__;
    }
    private static final int __PTHREAD_RWLOCKATTR_SIZE__ = (int)16L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCKATTR_SIZE__ 16
     * }
     */
    public static int __PTHREAD_RWLOCKATTR_SIZE__() {
        return __PTHREAD_RWLOCKATTR_SIZE__;
    }
    private static final int _FORTIFY_SOURCE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _FORTIFY_SOURCE 2
     * }
     */
    public static int _FORTIFY_SOURCE() {
        return _FORTIFY_SOURCE;
    }
    private static final int _POSIX_THREAD_KEYS_MAX = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_KEYS_MAX 128
     * }
     */
    public static int _POSIX_THREAD_KEYS_MAX() {
        return _POSIX_THREAD_KEYS_MAX;
    }
    private static final int F_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define F_OK 0
     * }
     */
    public static int F_OK() {
        return F_OK;
    }
    private static final int SEEK_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEEK_SET 0
     * }
     */
    public static int SEEK_SET() {
        return SEEK_SET;
    }
    private static final int SEEK_CUR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEEK_CUR 1
     * }
     */
    public static int SEEK_CUR() {
        return SEEK_CUR;
    }
    private static final int SEEK_END = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEEK_END 2
     * }
     */
    public static int SEEK_END() {
        return SEEK_END;
    }
    private static final int SEEK_HOLE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SEEK_HOLE 3
     * }
     */
    public static int SEEK_HOLE() {
        return SEEK_HOLE;
    }
    private static final int SEEK_DATA = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SEEK_DATA 4
     * }
     */
    public static int SEEK_DATA() {
        return SEEK_DATA;
    }
    private static final int ACCESSX_MAX_DESCRIPTORS = (int)100L;
    /**
     * {@snippet lang=c :
     * #define ACCESSX_MAX_DESCRIPTORS 100
     * }
     */
    public static int ACCESSX_MAX_DESCRIPTORS() {
        return ACCESSX_MAX_DESCRIPTORS;
    }
    private static final int _PC_LINK_MAX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _PC_LINK_MAX 1
     * }
     */
    public static int _PC_LINK_MAX() {
        return _PC_LINK_MAX;
    }
    private static final int _PC_MAX_CANON = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _PC_MAX_CANON 2
     * }
     */
    public static int _PC_MAX_CANON() {
        return _PC_MAX_CANON;
    }
    private static final int _PC_MAX_INPUT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _PC_MAX_INPUT 3
     * }
     */
    public static int _PC_MAX_INPUT() {
        return _PC_MAX_INPUT;
    }
    private static final int _PC_NAME_MAX = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _PC_NAME_MAX 4
     * }
     */
    public static int _PC_NAME_MAX() {
        return _PC_NAME_MAX;
    }
    private static final int _PC_PATH_MAX = (int)5L;
    /**
     * {@snippet lang=c :
     * #define _PC_PATH_MAX 5
     * }
     */
    public static int _PC_PATH_MAX() {
        return _PC_PATH_MAX;
    }
    private static final int _PC_PIPE_BUF = (int)6L;
    /**
     * {@snippet lang=c :
     * #define _PC_PIPE_BUF 6
     * }
     */
    public static int _PC_PIPE_BUF() {
        return _PC_PIPE_BUF;
    }
    private static final int _PC_CHOWN_RESTRICTED = (int)7L;
    /**
     * {@snippet lang=c :
     * #define _PC_CHOWN_RESTRICTED 7
     * }
     */
    public static int _PC_CHOWN_RESTRICTED() {
        return _PC_CHOWN_RESTRICTED;
    }
    private static final int _PC_NO_TRUNC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _PC_NO_TRUNC 8
     * }
     */
    public static int _PC_NO_TRUNC() {
        return _PC_NO_TRUNC;
    }
    private static final int _PC_VDISABLE = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _PC_VDISABLE 9
     * }
     */
    public static int _PC_VDISABLE() {
        return _PC_VDISABLE;
    }
    private static final int _PC_NAME_CHARS_MAX = (int)10L;
    /**
     * {@snippet lang=c :
     * #define _PC_NAME_CHARS_MAX 10
     * }
     */
    public static int _PC_NAME_CHARS_MAX() {
        return _PC_NAME_CHARS_MAX;
    }
    private static final int _PC_CASE_SENSITIVE = (int)11L;
    /**
     * {@snippet lang=c :
     * #define _PC_CASE_SENSITIVE 11
     * }
     */
    public static int _PC_CASE_SENSITIVE() {
        return _PC_CASE_SENSITIVE;
    }
    private static final int _PC_CASE_PRESERVING = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _PC_CASE_PRESERVING 12
     * }
     */
    public static int _PC_CASE_PRESERVING() {
        return _PC_CASE_PRESERVING;
    }
    private static final int _PC_EXTENDED_SECURITY_NP = (int)13L;
    /**
     * {@snippet lang=c :
     * #define _PC_EXTENDED_SECURITY_NP 13
     * }
     */
    public static int _PC_EXTENDED_SECURITY_NP() {
        return _PC_EXTENDED_SECURITY_NP;
    }
    private static final int _PC_AUTH_OPAQUE_NP = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _PC_AUTH_OPAQUE_NP 14
     * }
     */
    public static int _PC_AUTH_OPAQUE_NP() {
        return _PC_AUTH_OPAQUE_NP;
    }
    private static final int _PC_2_SYMLINKS = (int)15L;
    /**
     * {@snippet lang=c :
     * #define _PC_2_SYMLINKS 15
     * }
     */
    public static int _PC_2_SYMLINKS() {
        return _PC_2_SYMLINKS;
    }
    private static final int _PC_ALLOC_SIZE_MIN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _PC_ALLOC_SIZE_MIN 16
     * }
     */
    public static int _PC_ALLOC_SIZE_MIN() {
        return _PC_ALLOC_SIZE_MIN;
    }
    private static final int _PC_ASYNC_IO = (int)17L;
    /**
     * {@snippet lang=c :
     * #define _PC_ASYNC_IO 17
     * }
     */
    public static int _PC_ASYNC_IO() {
        return _PC_ASYNC_IO;
    }
    private static final int _PC_FILESIZEBITS = (int)18L;
    /**
     * {@snippet lang=c :
     * #define _PC_FILESIZEBITS 18
     * }
     */
    public static int _PC_FILESIZEBITS() {
        return _PC_FILESIZEBITS;
    }
    private static final int _PC_PRIO_IO = (int)19L;
    /**
     * {@snippet lang=c :
     * #define _PC_PRIO_IO 19
     * }
     */
    public static int _PC_PRIO_IO() {
        return _PC_PRIO_IO;
    }
    private static final int _PC_REC_INCR_XFER_SIZE = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _PC_REC_INCR_XFER_SIZE 20
     * }
     */
    public static int _PC_REC_INCR_XFER_SIZE() {
        return _PC_REC_INCR_XFER_SIZE;
    }
    private static final int _PC_REC_MAX_XFER_SIZE = (int)21L;
    /**
     * {@snippet lang=c :
     * #define _PC_REC_MAX_XFER_SIZE 21
     * }
     */
    public static int _PC_REC_MAX_XFER_SIZE() {
        return _PC_REC_MAX_XFER_SIZE;
    }
    private static final int _PC_REC_MIN_XFER_SIZE = (int)22L;
    /**
     * {@snippet lang=c :
     * #define _PC_REC_MIN_XFER_SIZE 22
     * }
     */
    public static int _PC_REC_MIN_XFER_SIZE() {
        return _PC_REC_MIN_XFER_SIZE;
    }
    private static final int _PC_REC_XFER_ALIGN = (int)23L;
    /**
     * {@snippet lang=c :
     * #define _PC_REC_XFER_ALIGN 23
     * }
     */
    public static int _PC_REC_XFER_ALIGN() {
        return _PC_REC_XFER_ALIGN;
    }
    private static final int _PC_SYMLINK_MAX = (int)24L;
    /**
     * {@snippet lang=c :
     * #define _PC_SYMLINK_MAX 24
     * }
     */
    public static int _PC_SYMLINK_MAX() {
        return _PC_SYMLINK_MAX;
    }
    private static final int _PC_SYNC_IO = (int)25L;
    /**
     * {@snippet lang=c :
     * #define _PC_SYNC_IO 25
     * }
     */
    public static int _PC_SYNC_IO() {
        return _PC_SYNC_IO;
    }
    private static final int _PC_XATTR_SIZE_BITS = (int)26L;
    /**
     * {@snippet lang=c :
     * #define _PC_XATTR_SIZE_BITS 26
     * }
     */
    public static int _PC_XATTR_SIZE_BITS() {
        return _PC_XATTR_SIZE_BITS;
    }
    private static final int _PC_MIN_HOLE_SIZE = (int)27L;
    /**
     * {@snippet lang=c :
     * #define _PC_MIN_HOLE_SIZE 27
     * }
     */
    public static int _PC_MIN_HOLE_SIZE() {
        return _PC_MIN_HOLE_SIZE;
    }
    private static final int _CS_PATH = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CS_PATH 1
     * }
     */
    public static int _CS_PATH() {
        return _CS_PATH;
    }
    private static final int USE_CLANG_STDDEF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define USE_CLANG_STDDEF 0
     * }
     */
    public static int USE_CLANG_STDDEF() {
        return USE_CLANG_STDDEF;
    }
    private static final int __API_TO_BE_DEPRECATED = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED() {
        return __API_TO_BE_DEPRECATED;
    }
    private static final int __API_TO_BE_DEPRECATED_MACOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_MACOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_MACOS() {
        return __API_TO_BE_DEPRECATED_MACOS;
    }
    private static final int __API_TO_BE_DEPRECATED_IOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_IOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_IOS() {
        return __API_TO_BE_DEPRECATED_IOS;
    }
    private static final int __API_TO_BE_DEPRECATED_MACCATALYST = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_MACCATALYST 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_MACCATALYST() {
        return __API_TO_BE_DEPRECATED_MACCATALYST;
    }
    private static final int __API_TO_BE_DEPRECATED_WATCHOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_WATCHOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_WATCHOS() {
        return __API_TO_BE_DEPRECATED_WATCHOS;
    }
    private static final int __API_TO_BE_DEPRECATED_TVOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_TVOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_TVOS() {
        return __API_TO_BE_DEPRECATED_TVOS;
    }
    private static final int __API_TO_BE_DEPRECATED_DRIVERKIT = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_DRIVERKIT 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_DRIVERKIT() {
        return __API_TO_BE_DEPRECATED_DRIVERKIT;
    }
    private static final int __API_TO_BE_DEPRECATED_VISIONOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_VISIONOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_VISIONOS() {
        return __API_TO_BE_DEPRECATED_VISIONOS;
    }
    private static final int __MAC_10_0 = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_0 1000
     * }
     */
    public static int __MAC_10_0() {
        return __MAC_10_0;
    }
    private static final int __MAC_10_1 = (int)1010L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_1 1010
     * }
     */
    public static int __MAC_10_1() {
        return __MAC_10_1;
    }
    private static final int __MAC_10_2 = (int)1020L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_2 1020
     * }
     */
    public static int __MAC_10_2() {
        return __MAC_10_2;
    }
    private static final int __MAC_10_3 = (int)1030L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_3 1030
     * }
     */
    public static int __MAC_10_3() {
        return __MAC_10_3;
    }
    private static final int __MAC_10_4 = (int)1040L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_4 1040
     * }
     */
    public static int __MAC_10_4() {
        return __MAC_10_4;
    }
    private static final int __MAC_10_5 = (int)1050L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_5 1050
     * }
     */
    public static int __MAC_10_5() {
        return __MAC_10_5;
    }
    private static final int __MAC_10_6 = (int)1060L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_6 1060
     * }
     */
    public static int __MAC_10_6() {
        return __MAC_10_6;
    }
    private static final int __MAC_10_7 = (int)1070L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_7 1070
     * }
     */
    public static int __MAC_10_7() {
        return __MAC_10_7;
    }
    private static final int __MAC_10_8 = (int)1080L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_8 1080
     * }
     */
    public static int __MAC_10_8() {
        return __MAC_10_8;
    }
    private static final int __MAC_10_9 = (int)1090L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_9 1090
     * }
     */
    public static int __MAC_10_9() {
        return __MAC_10_9;
    }
    private static final int __MAC_10_10 = (int)101000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_10 101000
     * }
     */
    public static int __MAC_10_10() {
        return __MAC_10_10;
    }
    private static final int __MAC_10_10_2 = (int)101002L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_10_2 101002
     * }
     */
    public static int __MAC_10_10_2() {
        return __MAC_10_10_2;
    }
    private static final int __MAC_10_10_3 = (int)101003L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_10_3 101003
     * }
     */
    public static int __MAC_10_10_3() {
        return __MAC_10_10_3;
    }
    private static final int __MAC_10_11 = (int)101100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_11 101100
     * }
     */
    public static int __MAC_10_11() {
        return __MAC_10_11;
    }
    private static final int __MAC_10_11_2 = (int)101102L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_11_2 101102
     * }
     */
    public static int __MAC_10_11_2() {
        return __MAC_10_11_2;
    }
    private static final int __MAC_10_11_3 = (int)101103L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_11_3 101103
     * }
     */
    public static int __MAC_10_11_3() {
        return __MAC_10_11_3;
    }
    private static final int __MAC_10_11_4 = (int)101104L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_11_4 101104
     * }
     */
    public static int __MAC_10_11_4() {
        return __MAC_10_11_4;
    }
    private static final int __MAC_10_12 = (int)101200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_12 101200
     * }
     */
    public static int __MAC_10_12() {
        return __MAC_10_12;
    }
    private static final int __MAC_10_12_1 = (int)101201L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_12_1 101201
     * }
     */
    public static int __MAC_10_12_1() {
        return __MAC_10_12_1;
    }
    private static final int __MAC_10_12_2 = (int)101202L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_12_2 101202
     * }
     */
    public static int __MAC_10_12_2() {
        return __MAC_10_12_2;
    }
    private static final int __MAC_10_12_4 = (int)101204L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_12_4 101204
     * }
     */
    public static int __MAC_10_12_4() {
        return __MAC_10_12_4;
    }
    private static final int __MAC_10_13 = (int)101300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_13 101300
     * }
     */
    public static int __MAC_10_13() {
        return __MAC_10_13;
    }
    private static final int __MAC_10_13_1 = (int)101301L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_13_1 101301
     * }
     */
    public static int __MAC_10_13_1() {
        return __MAC_10_13_1;
    }
    private static final int __MAC_10_13_2 = (int)101302L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_13_2 101302
     * }
     */
    public static int __MAC_10_13_2() {
        return __MAC_10_13_2;
    }
    private static final int __MAC_10_13_4 = (int)101304L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_13_4 101304
     * }
     */
    public static int __MAC_10_13_4() {
        return __MAC_10_13_4;
    }
    private static final int __MAC_10_14 = (int)101400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14 101400
     * }
     */
    public static int __MAC_10_14() {
        return __MAC_10_14;
    }
    private static final int __MAC_10_14_1 = (int)101401L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14_1 101401
     * }
     */
    public static int __MAC_10_14_1() {
        return __MAC_10_14_1;
    }
    private static final int __MAC_10_14_4 = (int)101404L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14_4 101404
     * }
     */
    public static int __MAC_10_14_4() {
        return __MAC_10_14_4;
    }
    private static final int __MAC_10_14_5 = (int)101405L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14_5 101405
     * }
     */
    public static int __MAC_10_14_5() {
        return __MAC_10_14_5;
    }
    private static final int __MAC_10_14_6 = (int)101406L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14_6 101406
     * }
     */
    public static int __MAC_10_14_6() {
        return __MAC_10_14_6;
    }
    private static final int __MAC_10_15 = (int)101500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_15 101500
     * }
     */
    public static int __MAC_10_15() {
        return __MAC_10_15;
    }
    private static final int __MAC_10_15_1 = (int)101501L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_15_1 101501
     * }
     */
    public static int __MAC_10_15_1() {
        return __MAC_10_15_1;
    }
    private static final int __MAC_10_15_4 = (int)101504L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_15_4 101504
     * }
     */
    public static int __MAC_10_15_4() {
        return __MAC_10_15_4;
    }
    private static final int __MAC_10_16 = (int)101600L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_16 101600
     * }
     */
    public static int __MAC_10_16() {
        return __MAC_10_16;
    }
    private static final int __MAC_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_0 110000
     * }
     */
    public static int __MAC_11_0() {
        return __MAC_11_0;
    }
    private static final int __MAC_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_1 110100
     * }
     */
    public static int __MAC_11_1() {
        return __MAC_11_1;
    }
    private static final int __MAC_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_3 110300
     * }
     */
    public static int __MAC_11_3() {
        return __MAC_11_3;
    }
    private static final int __MAC_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_4 110400
     * }
     */
    public static int __MAC_11_4() {
        return __MAC_11_4;
    }
    private static final int __MAC_11_5 = (int)110500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_5 110500
     * }
     */
    public static int __MAC_11_5() {
        return __MAC_11_5;
    }
    private static final int __MAC_11_6 = (int)110600L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_6 110600
     * }
     */
    public static int __MAC_11_6() {
        return __MAC_11_6;
    }
    private static final int __MAC_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_0 120000
     * }
     */
    public static int __MAC_12_0() {
        return __MAC_12_0;
    }
    private static final int __MAC_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_1 120100
     * }
     */
    public static int __MAC_12_1() {
        return __MAC_12_1;
    }
    private static final int __MAC_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_2 120200
     * }
     */
    public static int __MAC_12_2() {
        return __MAC_12_2;
    }
    private static final int __MAC_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_3 120300
     * }
     */
    public static int __MAC_12_3() {
        return __MAC_12_3;
    }
    private static final int __MAC_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_4 120400
     * }
     */
    public static int __MAC_12_4() {
        return __MAC_12_4;
    }
    private static final int __MAC_12_5 = (int)120500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_5 120500
     * }
     */
    public static int __MAC_12_5() {
        return __MAC_12_5;
    }
    private static final int __MAC_12_6 = (int)120600L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_6 120600
     * }
     */
    public static int __MAC_12_6() {
        return __MAC_12_6;
    }
    private static final int __MAC_12_7 = (int)120700L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_7 120700
     * }
     */
    public static int __MAC_12_7() {
        return __MAC_12_7;
    }
    private static final int __MAC_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_0 130000
     * }
     */
    public static int __MAC_13_0() {
        return __MAC_13_0;
    }
    private static final int __MAC_13_1 = (int)130100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_1 130100
     * }
     */
    public static int __MAC_13_1() {
        return __MAC_13_1;
    }
    private static final int __MAC_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_2 130200
     * }
     */
    public static int __MAC_13_2() {
        return __MAC_13_2;
    }
    private static final int __MAC_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_3 130300
     * }
     */
    public static int __MAC_13_3() {
        return __MAC_13_3;
    }
    private static final int __MAC_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_4 130400
     * }
     */
    public static int __MAC_13_4() {
        return __MAC_13_4;
    }
    private static final int __MAC_13_5 = (int)130500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_5 130500
     * }
     */
    public static int __MAC_13_5() {
        return __MAC_13_5;
    }
    private static final int __MAC_13_6 = (int)130600L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_6 130600
     * }
     */
    public static int __MAC_13_6() {
        return __MAC_13_6;
    }
    private static final int __MAC_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_0 140000
     * }
     */
    public static int __MAC_14_0() {
        return __MAC_14_0;
    }
    private static final int __MAC_14_1 = (int)140100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_1 140100
     * }
     */
    public static int __MAC_14_1() {
        return __MAC_14_1;
    }
    private static final int __MAC_14_2 = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_2 140200
     * }
     */
    public static int __MAC_14_2() {
        return __MAC_14_2;
    }
    private static final int __MAC_14_3 = (int)140300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_3 140300
     * }
     */
    public static int __MAC_14_3() {
        return __MAC_14_3;
    }
    private static final int __MAC_14_4 = (int)140400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_4 140400
     * }
     */
    public static int __MAC_14_4() {
        return __MAC_14_4;
    }
    private static final int __MAC_14_5 = (int)140500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_5 140500
     * }
     */
    public static int __MAC_14_5() {
        return __MAC_14_5;
    }
    private static final int __MAC_15_0 = (int)150000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_15_0 150000
     * }
     */
    public static int __MAC_15_0() {
        return __MAC_15_0;
    }
    private static final int __MAC_15_1 = (int)150100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_15_1 150100
     * }
     */
    public static int __MAC_15_1() {
        return __MAC_15_1;
    }
    private static final int __MAC_15_2 = (int)150200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_15_2 150200
     * }
     */
    public static int __MAC_15_2() {
        return __MAC_15_2;
    }
    private static final int __IPHONE_2_0 = (int)20000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_2_0 20000
     * }
     */
    public static int __IPHONE_2_0() {
        return __IPHONE_2_0;
    }
    private static final int __IPHONE_2_1 = (int)20100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_2_1 20100
     * }
     */
    public static int __IPHONE_2_1() {
        return __IPHONE_2_1;
    }
    private static final int __IPHONE_2_2 = (int)20200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_2_2 20200
     * }
     */
    public static int __IPHONE_2_2() {
        return __IPHONE_2_2;
    }
    private static final int __IPHONE_3_0 = (int)30000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_3_0 30000
     * }
     */
    public static int __IPHONE_3_0() {
        return __IPHONE_3_0;
    }
    private static final int __IPHONE_3_1 = (int)30100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_3_1 30100
     * }
     */
    public static int __IPHONE_3_1() {
        return __IPHONE_3_1;
    }
    private static final int __IPHONE_3_2 = (int)30200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_3_2 30200
     * }
     */
    public static int __IPHONE_3_2() {
        return __IPHONE_3_2;
    }
    private static final int __IPHONE_4_0 = (int)40000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_4_0 40000
     * }
     */
    public static int __IPHONE_4_0() {
        return __IPHONE_4_0;
    }
    private static final int __IPHONE_4_1 = (int)40100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_4_1 40100
     * }
     */
    public static int __IPHONE_4_1() {
        return __IPHONE_4_1;
    }
    private static final int __IPHONE_4_2 = (int)40200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_4_2 40200
     * }
     */
    public static int __IPHONE_4_2() {
        return __IPHONE_4_2;
    }
    private static final int __IPHONE_4_3 = (int)40300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_4_3 40300
     * }
     */
    public static int __IPHONE_4_3() {
        return __IPHONE_4_3;
    }
    private static final int __IPHONE_5_0 = (int)50000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_5_0 50000
     * }
     */
    public static int __IPHONE_5_0() {
        return __IPHONE_5_0;
    }
    private static final int __IPHONE_5_1 = (int)50100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_5_1 50100
     * }
     */
    public static int __IPHONE_5_1() {
        return __IPHONE_5_1;
    }
    private static final int __IPHONE_6_0 = (int)60000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_6_0 60000
     * }
     */
    public static int __IPHONE_6_0() {
        return __IPHONE_6_0;
    }
    private static final int __IPHONE_6_1 = (int)60100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_6_1 60100
     * }
     */
    public static int __IPHONE_6_1() {
        return __IPHONE_6_1;
    }
    private static final int __IPHONE_7_0 = (int)70000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_7_0 70000
     * }
     */
    public static int __IPHONE_7_0() {
        return __IPHONE_7_0;
    }
    private static final int __IPHONE_7_1 = (int)70100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_7_1 70100
     * }
     */
    public static int __IPHONE_7_1() {
        return __IPHONE_7_1;
    }
    private static final int __IPHONE_8_0 = (int)80000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_0 80000
     * }
     */
    public static int __IPHONE_8_0() {
        return __IPHONE_8_0;
    }
    private static final int __IPHONE_8_1 = (int)80100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_1 80100
     * }
     */
    public static int __IPHONE_8_1() {
        return __IPHONE_8_1;
    }
    private static final int __IPHONE_8_2 = (int)80200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_2 80200
     * }
     */
    public static int __IPHONE_8_2() {
        return __IPHONE_8_2;
    }
    private static final int __IPHONE_8_3 = (int)80300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_3 80300
     * }
     */
    public static int __IPHONE_8_3() {
        return __IPHONE_8_3;
    }
    private static final int __IPHONE_8_4 = (int)80400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_4 80400
     * }
     */
    public static int __IPHONE_8_4() {
        return __IPHONE_8_4;
    }
    private static final int __IPHONE_9_0 = (int)90000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_9_0 90000
     * }
     */
    public static int __IPHONE_9_0() {
        return __IPHONE_9_0;
    }
    private static final int __IPHONE_9_1 = (int)90100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_9_1 90100
     * }
     */
    public static int __IPHONE_9_1() {
        return __IPHONE_9_1;
    }
    private static final int __IPHONE_9_2 = (int)90200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_9_2 90200
     * }
     */
    public static int __IPHONE_9_2() {
        return __IPHONE_9_2;
    }
    private static final int __IPHONE_9_3 = (int)90300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_9_3 90300
     * }
     */
    public static int __IPHONE_9_3() {
        return __IPHONE_9_3;
    }
    private static final int __IPHONE_10_0 = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_10_0 100000
     * }
     */
    public static int __IPHONE_10_0() {
        return __IPHONE_10_0;
    }
    private static final int __IPHONE_10_1 = (int)100100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_10_1 100100
     * }
     */
    public static int __IPHONE_10_1() {
        return __IPHONE_10_1;
    }
    private static final int __IPHONE_10_2 = (int)100200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_10_2 100200
     * }
     */
    public static int __IPHONE_10_2() {
        return __IPHONE_10_2;
    }
    private static final int __IPHONE_10_3 = (int)100300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_10_3 100300
     * }
     */
    public static int __IPHONE_10_3() {
        return __IPHONE_10_3;
    }
    private static final int __IPHONE_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_0 110000
     * }
     */
    public static int __IPHONE_11_0() {
        return __IPHONE_11_0;
    }
    private static final int __IPHONE_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_1 110100
     * }
     */
    public static int __IPHONE_11_1() {
        return __IPHONE_11_1;
    }
    private static final int __IPHONE_11_2 = (int)110200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_2 110200
     * }
     */
    public static int __IPHONE_11_2() {
        return __IPHONE_11_2;
    }
    private static final int __IPHONE_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_3 110300
     * }
     */
    public static int __IPHONE_11_3() {
        return __IPHONE_11_3;
    }
    private static final int __IPHONE_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_4 110400
     * }
     */
    public static int __IPHONE_11_4() {
        return __IPHONE_11_4;
    }
    private static final int __IPHONE_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_0 120000
     * }
     */
    public static int __IPHONE_12_0() {
        return __IPHONE_12_0;
    }
    private static final int __IPHONE_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_1 120100
     * }
     */
    public static int __IPHONE_12_1() {
        return __IPHONE_12_1;
    }
    private static final int __IPHONE_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_2 120200
     * }
     */
    public static int __IPHONE_12_2() {
        return __IPHONE_12_2;
    }
    private static final int __IPHONE_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_3 120300
     * }
     */
    public static int __IPHONE_12_3() {
        return __IPHONE_12_3;
    }
    private static final int __IPHONE_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_4 120400
     * }
     */
    public static int __IPHONE_12_4() {
        return __IPHONE_12_4;
    }
    private static final int __IPHONE_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_0 130000
     * }
     */
    public static int __IPHONE_13_0() {
        return __IPHONE_13_0;
    }
    private static final int __IPHONE_13_1 = (int)130100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_1 130100
     * }
     */
    public static int __IPHONE_13_1() {
        return __IPHONE_13_1;
    }
    private static final int __IPHONE_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_2 130200
     * }
     */
    public static int __IPHONE_13_2() {
        return __IPHONE_13_2;
    }
    private static final int __IPHONE_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_3 130300
     * }
     */
    public static int __IPHONE_13_3() {
        return __IPHONE_13_3;
    }
    private static final int __IPHONE_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_4 130400
     * }
     */
    public static int __IPHONE_13_4() {
        return __IPHONE_13_4;
    }
    private static final int __IPHONE_13_5 = (int)130500L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_5 130500
     * }
     */
    public static int __IPHONE_13_5() {
        return __IPHONE_13_5;
    }
    private static final int __IPHONE_13_6 = (int)130600L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_6 130600
     * }
     */
    public static int __IPHONE_13_6() {
        return __IPHONE_13_6;
    }
    private static final int __IPHONE_13_7 = (int)130700L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_7 130700
     * }
     */
    public static int __IPHONE_13_7() {
        return __IPHONE_13_7;
    }
    private static final int __IPHONE_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_0 140000
     * }
     */
    public static int __IPHONE_14_0() {
        return __IPHONE_14_0;
    }
    private static final int __IPHONE_14_1 = (int)140100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_1 140100
     * }
     */
    public static int __IPHONE_14_1() {
        return __IPHONE_14_1;
    }
    private static final int __IPHONE_14_2 = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_2 140200
     * }
     */
    public static int __IPHONE_14_2() {
        return __IPHONE_14_2;
    }
    private static final int __IPHONE_14_3 = (int)140300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_3 140300
     * }
     */
    public static int __IPHONE_14_3() {
        return __IPHONE_14_3;
    }
    private static final int __IPHONE_14_5 = (int)140500L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_5 140500
     * }
     */
    public static int __IPHONE_14_5() {
        return __IPHONE_14_5;
    }
    private static final int __IPHONE_14_4 = (int)140400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_4 140400
     * }
     */
    public static int __IPHONE_14_4() {
        return __IPHONE_14_4;
    }
    private static final int __IPHONE_14_6 = (int)140600L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_6 140600
     * }
     */
    public static int __IPHONE_14_6() {
        return __IPHONE_14_6;
    }
    private static final int __IPHONE_14_7 = (int)140700L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_7 140700
     * }
     */
    public static int __IPHONE_14_7() {
        return __IPHONE_14_7;
    }
    private static final int __IPHONE_14_8 = (int)140800L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_8 140800
     * }
     */
    public static int __IPHONE_14_8() {
        return __IPHONE_14_8;
    }
    private static final int __IPHONE_15_0 = (int)150000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_0 150000
     * }
     */
    public static int __IPHONE_15_0() {
        return __IPHONE_15_0;
    }
    private static final int __IPHONE_15_1 = (int)150100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_1 150100
     * }
     */
    public static int __IPHONE_15_1() {
        return __IPHONE_15_1;
    }
    private static final int __IPHONE_15_2 = (int)150200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_2 150200
     * }
     */
    public static int __IPHONE_15_2() {
        return __IPHONE_15_2;
    }
    private static final int __IPHONE_15_3 = (int)150300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_3 150300
     * }
     */
    public static int __IPHONE_15_3() {
        return __IPHONE_15_3;
    }
    private static final int __IPHONE_15_4 = (int)150400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_4 150400
     * }
     */
    public static int __IPHONE_15_4() {
        return __IPHONE_15_4;
    }
    private static final int __IPHONE_15_5 = (int)150500L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_5 150500
     * }
     */
    public static int __IPHONE_15_5() {
        return __IPHONE_15_5;
    }
    private static final int __IPHONE_15_6 = (int)150600L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_6 150600
     * }
     */
    public static int __IPHONE_15_6() {
        return __IPHONE_15_6;
    }
    private static final int __IPHONE_15_7 = (int)150700L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_7 150700
     * }
     */
    public static int __IPHONE_15_7() {
        return __IPHONE_15_7;
    }
    private static final int __IPHONE_15_8 = (int)150800L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_8 150800
     * }
     */
    public static int __IPHONE_15_8() {
        return __IPHONE_15_8;
    }
    private static final int __IPHONE_16_0 = (int)160000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_0 160000
     * }
     */
    public static int __IPHONE_16_0() {
        return __IPHONE_16_0;
    }
    private static final int __IPHONE_16_1 = (int)160100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_1 160100
     * }
     */
    public static int __IPHONE_16_1() {
        return __IPHONE_16_1;
    }
    private static final int __IPHONE_16_2 = (int)160200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_2 160200
     * }
     */
    public static int __IPHONE_16_2() {
        return __IPHONE_16_2;
    }
    private static final int __IPHONE_16_3 = (int)160300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_3 160300
     * }
     */
    public static int __IPHONE_16_3() {
        return __IPHONE_16_3;
    }
    private static final int __IPHONE_16_4 = (int)160400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_4 160400
     * }
     */
    public static int __IPHONE_16_4() {
        return __IPHONE_16_4;
    }
    private static final int __IPHONE_16_5 = (int)160500L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_5 160500
     * }
     */
    public static int __IPHONE_16_5() {
        return __IPHONE_16_5;
    }
    private static final int __IPHONE_16_6 = (int)160600L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_6 160600
     * }
     */
    public static int __IPHONE_16_6() {
        return __IPHONE_16_6;
    }
    private static final int __IPHONE_16_7 = (int)160700L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_7 160700
     * }
     */
    public static int __IPHONE_16_7() {
        return __IPHONE_16_7;
    }
    private static final int __IPHONE_17_0 = (int)170000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_0 170000
     * }
     */
    public static int __IPHONE_17_0() {
        return __IPHONE_17_0;
    }
    private static final int __IPHONE_17_1 = (int)170100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_1 170100
     * }
     */
    public static int __IPHONE_17_1() {
        return __IPHONE_17_1;
    }
    private static final int __IPHONE_17_2 = (int)170200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_2 170200
     * }
     */
    public static int __IPHONE_17_2() {
        return __IPHONE_17_2;
    }
    private static final int __IPHONE_17_3 = (int)170300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_3 170300
     * }
     */
    public static int __IPHONE_17_3() {
        return __IPHONE_17_3;
    }
    private static final int __IPHONE_17_4 = (int)170400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_4 170400
     * }
     */
    public static int __IPHONE_17_4() {
        return __IPHONE_17_4;
    }
    private static final int __IPHONE_17_5 = (int)170500L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_5 170500
     * }
     */
    public static int __IPHONE_17_5() {
        return __IPHONE_17_5;
    }
    private static final int __IPHONE_18_0 = (int)180000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_18_0 180000
     * }
     */
    public static int __IPHONE_18_0() {
        return __IPHONE_18_0;
    }
    private static final int __IPHONE_18_1 = (int)180100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_18_1 180100
     * }
     */
    public static int __IPHONE_18_1() {
        return __IPHONE_18_1;
    }
    private static final int __IPHONE_18_2 = (int)180200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_18_2 180200
     * }
     */
    public static int __IPHONE_18_2() {
        return __IPHONE_18_2;
    }
    private static final int __WATCHOS_1_0 = (int)10000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_1_0 10000
     * }
     */
    public static int __WATCHOS_1_0() {
        return __WATCHOS_1_0;
    }
    private static final int __WATCHOS_2_0 = (int)20000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_2_0 20000
     * }
     */
    public static int __WATCHOS_2_0() {
        return __WATCHOS_2_0;
    }
    private static final int __WATCHOS_2_1 = (int)20100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_2_1 20100
     * }
     */
    public static int __WATCHOS_2_1() {
        return __WATCHOS_2_1;
    }
    private static final int __WATCHOS_2_2 = (int)20200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_2_2 20200
     * }
     */
    public static int __WATCHOS_2_2() {
        return __WATCHOS_2_2;
    }
    private static final int __WATCHOS_3_0 = (int)30000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_3_0 30000
     * }
     */
    public static int __WATCHOS_3_0() {
        return __WATCHOS_3_0;
    }
    private static final int __WATCHOS_3_1 = (int)30100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_3_1 30100
     * }
     */
    public static int __WATCHOS_3_1() {
        return __WATCHOS_3_1;
    }
    private static final int __WATCHOS_3_1_1 = (int)30101L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_3_1_1 30101
     * }
     */
    public static int __WATCHOS_3_1_1() {
        return __WATCHOS_3_1_1;
    }
    private static final int __WATCHOS_3_2 = (int)30200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_3_2 30200
     * }
     */
    public static int __WATCHOS_3_2() {
        return __WATCHOS_3_2;
    }
    private static final int __WATCHOS_4_0 = (int)40000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_4_0 40000
     * }
     */
    public static int __WATCHOS_4_0() {
        return __WATCHOS_4_0;
    }
    private static final int __WATCHOS_4_1 = (int)40100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_4_1 40100
     * }
     */
    public static int __WATCHOS_4_1() {
        return __WATCHOS_4_1;
    }
    private static final int __WATCHOS_4_2 = (int)40200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_4_2 40200
     * }
     */
    public static int __WATCHOS_4_2() {
        return __WATCHOS_4_2;
    }
    private static final int __WATCHOS_4_3 = (int)40300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_4_3 40300
     * }
     */
    public static int __WATCHOS_4_3() {
        return __WATCHOS_4_3;
    }
    private static final int __WATCHOS_5_0 = (int)50000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_5_0 50000
     * }
     */
    public static int __WATCHOS_5_0() {
        return __WATCHOS_5_0;
    }
    private static final int __WATCHOS_5_1 = (int)50100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_5_1 50100
     * }
     */
    public static int __WATCHOS_5_1() {
        return __WATCHOS_5_1;
    }
    private static final int __WATCHOS_5_2 = (int)50200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_5_2 50200
     * }
     */
    public static int __WATCHOS_5_2() {
        return __WATCHOS_5_2;
    }
    private static final int __WATCHOS_5_3 = (int)50300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_5_3 50300
     * }
     */
    public static int __WATCHOS_5_3() {
        return __WATCHOS_5_3;
    }
    private static final int __WATCHOS_6_0 = (int)60000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_6_0 60000
     * }
     */
    public static int __WATCHOS_6_0() {
        return __WATCHOS_6_0;
    }
    private static final int __WATCHOS_6_1 = (int)60100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_6_1 60100
     * }
     */
    public static int __WATCHOS_6_1() {
        return __WATCHOS_6_1;
    }
    private static final int __WATCHOS_6_2 = (int)60200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_6_2 60200
     * }
     */
    public static int __WATCHOS_6_2() {
        return __WATCHOS_6_2;
    }
    private static final int __WATCHOS_7_0 = (int)70000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_0 70000
     * }
     */
    public static int __WATCHOS_7_0() {
        return __WATCHOS_7_0;
    }
    private static final int __WATCHOS_7_1 = (int)70100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_1 70100
     * }
     */
    public static int __WATCHOS_7_1() {
        return __WATCHOS_7_1;
    }
    private static final int __WATCHOS_7_2 = (int)70200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_2 70200
     * }
     */
    public static int __WATCHOS_7_2() {
        return __WATCHOS_7_2;
    }
    private static final int __WATCHOS_7_3 = (int)70300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_3 70300
     * }
     */
    public static int __WATCHOS_7_3() {
        return __WATCHOS_7_3;
    }
    private static final int __WATCHOS_7_4 = (int)70400L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_4 70400
     * }
     */
    public static int __WATCHOS_7_4() {
        return __WATCHOS_7_4;
    }
    private static final int __WATCHOS_7_5 = (int)70500L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_5 70500
     * }
     */
    public static int __WATCHOS_7_5() {
        return __WATCHOS_7_5;
    }
    private static final int __WATCHOS_7_6 = (int)70600L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_6 70600
     * }
     */
    public static int __WATCHOS_7_6() {
        return __WATCHOS_7_6;
    }
    private static final int __WATCHOS_8_0 = (int)80000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_0 80000
     * }
     */
    public static int __WATCHOS_8_0() {
        return __WATCHOS_8_0;
    }
    private static final int __WATCHOS_8_1 = (int)80100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_1 80100
     * }
     */
    public static int __WATCHOS_8_1() {
        return __WATCHOS_8_1;
    }
    private static final int __WATCHOS_8_3 = (int)80300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_3 80300
     * }
     */
    public static int __WATCHOS_8_3() {
        return __WATCHOS_8_3;
    }
    private static final int __WATCHOS_8_4 = (int)80400L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_4 80400
     * }
     */
    public static int __WATCHOS_8_4() {
        return __WATCHOS_8_4;
    }
    private static final int __WATCHOS_8_5 = (int)80500L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_5 80500
     * }
     */
    public static int __WATCHOS_8_5() {
        return __WATCHOS_8_5;
    }
    private static final int __WATCHOS_8_6 = (int)80600L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_6 80600
     * }
     */
    public static int __WATCHOS_8_6() {
        return __WATCHOS_8_6;
    }
    private static final int __WATCHOS_8_7 = (int)80700L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_7 80700
     * }
     */
    public static int __WATCHOS_8_7() {
        return __WATCHOS_8_7;
    }
    private static final int __WATCHOS_8_8 = (int)80800L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_8 80800
     * }
     */
    public static int __WATCHOS_8_8() {
        return __WATCHOS_8_8;
    }
    private static final int __WATCHOS_9_0 = (int)90000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_0 90000
     * }
     */
    public static int __WATCHOS_9_0() {
        return __WATCHOS_9_0;
    }
    private static final int __WATCHOS_9_1 = (int)90100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_1 90100
     * }
     */
    public static int __WATCHOS_9_1() {
        return __WATCHOS_9_1;
    }
    private static final int __WATCHOS_9_2 = (int)90200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_2 90200
     * }
     */
    public static int __WATCHOS_9_2() {
        return __WATCHOS_9_2;
    }
    private static final int __WATCHOS_9_3 = (int)90300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_3 90300
     * }
     */
    public static int __WATCHOS_9_3() {
        return __WATCHOS_9_3;
    }
    private static final int __WATCHOS_9_4 = (int)90400L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_4 90400
     * }
     */
    public static int __WATCHOS_9_4() {
        return __WATCHOS_9_4;
    }
    private static final int __WATCHOS_9_5 = (int)90500L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_5 90500
     * }
     */
    public static int __WATCHOS_9_5() {
        return __WATCHOS_9_5;
    }
    private static final int __WATCHOS_9_6 = (int)90600L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_6 90600
     * }
     */
    public static int __WATCHOS_9_6() {
        return __WATCHOS_9_6;
    }
    private static final int __WATCHOS_10_0 = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_0 100000
     * }
     */
    public static int __WATCHOS_10_0() {
        return __WATCHOS_10_0;
    }
    private static final int __WATCHOS_10_1 = (int)100100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_1 100100
     * }
     */
    public static int __WATCHOS_10_1() {
        return __WATCHOS_10_1;
    }
    private static final int __WATCHOS_10_2 = (int)100200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_2 100200
     * }
     */
    public static int __WATCHOS_10_2() {
        return __WATCHOS_10_2;
    }
    private static final int __WATCHOS_10_3 = (int)100300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_3 100300
     * }
     */
    public static int __WATCHOS_10_3() {
        return __WATCHOS_10_3;
    }
    private static final int __WATCHOS_10_4 = (int)100400L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_4 100400
     * }
     */
    public static int __WATCHOS_10_4() {
        return __WATCHOS_10_4;
    }
    private static final int __WATCHOS_10_5 = (int)100500L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_5 100500
     * }
     */
    public static int __WATCHOS_10_5() {
        return __WATCHOS_10_5;
    }
    private static final int __WATCHOS_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_11_0 110000
     * }
     */
    public static int __WATCHOS_11_0() {
        return __WATCHOS_11_0;
    }
    private static final int __WATCHOS_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_11_1 110100
     * }
     */
    public static int __WATCHOS_11_1() {
        return __WATCHOS_11_1;
    }
    private static final int __WATCHOS_11_2 = (int)110200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_11_2 110200
     * }
     */
    public static int __WATCHOS_11_2() {
        return __WATCHOS_11_2;
    }
    private static final int __TVOS_9_0 = (int)90000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_9_0 90000
     * }
     */
    public static int __TVOS_9_0() {
        return __TVOS_9_0;
    }
    private static final int __TVOS_9_1 = (int)90100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_9_1 90100
     * }
     */
    public static int __TVOS_9_1() {
        return __TVOS_9_1;
    }
    private static final int __TVOS_9_2 = (int)90200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_9_2 90200
     * }
     */
    public static int __TVOS_9_2() {
        return __TVOS_9_2;
    }
    private static final int __TVOS_10_0 = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_10_0 100000
     * }
     */
    public static int __TVOS_10_0() {
        return __TVOS_10_0;
    }
    private static final int __TVOS_10_0_1 = (int)100001L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_10_0_1 100001
     * }
     */
    public static int __TVOS_10_0_1() {
        return __TVOS_10_0_1;
    }
    private static final int __TVOS_10_1 = (int)100100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_10_1 100100
     * }
     */
    public static int __TVOS_10_1() {
        return __TVOS_10_1;
    }
    private static final int __TVOS_10_2 = (int)100200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_10_2 100200
     * }
     */
    public static int __TVOS_10_2() {
        return __TVOS_10_2;
    }
    private static final int __TVOS_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_0 110000
     * }
     */
    public static int __TVOS_11_0() {
        return __TVOS_11_0;
    }
    private static final int __TVOS_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_1 110100
     * }
     */
    public static int __TVOS_11_1() {
        return __TVOS_11_1;
    }
    private static final int __TVOS_11_2 = (int)110200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_2 110200
     * }
     */
    public static int __TVOS_11_2() {
        return __TVOS_11_2;
    }
    private static final int __TVOS_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_3 110300
     * }
     */
    public static int __TVOS_11_3() {
        return __TVOS_11_3;
    }
    private static final int __TVOS_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_4 110400
     * }
     */
    public static int __TVOS_11_4() {
        return __TVOS_11_4;
    }
    private static final int __TVOS_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_0 120000
     * }
     */
    public static int __TVOS_12_0() {
        return __TVOS_12_0;
    }
    private static final int __TVOS_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_1 120100
     * }
     */
    public static int __TVOS_12_1() {
        return __TVOS_12_1;
    }
    private static final int __TVOS_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_2 120200
     * }
     */
    public static int __TVOS_12_2() {
        return __TVOS_12_2;
    }
    private static final int __TVOS_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_3 120300
     * }
     */
    public static int __TVOS_12_3() {
        return __TVOS_12_3;
    }
    private static final int __TVOS_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_4 120400
     * }
     */
    public static int __TVOS_12_4() {
        return __TVOS_12_4;
    }
    private static final int __TVOS_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_13_0 130000
     * }
     */
    public static int __TVOS_13_0() {
        return __TVOS_13_0;
    }
    private static final int __TVOS_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_13_2 130200
     * }
     */
    public static int __TVOS_13_2() {
        return __TVOS_13_2;
    }
    private static final int __TVOS_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_13_3 130300
     * }
     */
    public static int __TVOS_13_3() {
        return __TVOS_13_3;
    }
    private static final int __TVOS_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_13_4 130400
     * }
     */
    public static int __TVOS_13_4() {
        return __TVOS_13_4;
    }
    private static final int __TVOS_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_0 140000
     * }
     */
    public static int __TVOS_14_0() {
        return __TVOS_14_0;
    }
    private static final int __TVOS_14_1 = (int)140100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_1 140100
     * }
     */
    public static int __TVOS_14_1() {
        return __TVOS_14_1;
    }
    private static final int __TVOS_14_2 = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_2 140200
     * }
     */
    public static int __TVOS_14_2() {
        return __TVOS_14_2;
    }
    private static final int __TVOS_14_3 = (int)140300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_3 140300
     * }
     */
    public static int __TVOS_14_3() {
        return __TVOS_14_3;
    }
    private static final int __TVOS_14_5 = (int)140500L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_5 140500
     * }
     */
    public static int __TVOS_14_5() {
        return __TVOS_14_5;
    }
    private static final int __TVOS_14_6 = (int)140600L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_6 140600
     * }
     */
    public static int __TVOS_14_6() {
        return __TVOS_14_6;
    }
    private static final int __TVOS_14_7 = (int)140700L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_7 140700
     * }
     */
    public static int __TVOS_14_7() {
        return __TVOS_14_7;
    }
    private static final int __TVOS_15_0 = (int)150000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_0 150000
     * }
     */
    public static int __TVOS_15_0() {
        return __TVOS_15_0;
    }
    private static final int __TVOS_15_1 = (int)150100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_1 150100
     * }
     */
    public static int __TVOS_15_1() {
        return __TVOS_15_1;
    }
    private static final int __TVOS_15_2 = (int)150200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_2 150200
     * }
     */
    public static int __TVOS_15_2() {
        return __TVOS_15_2;
    }
    private static final int __TVOS_15_3 = (int)150300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_3 150300
     * }
     */
    public static int __TVOS_15_3() {
        return __TVOS_15_3;
    }
    private static final int __TVOS_15_4 = (int)150400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_4 150400
     * }
     */
    public static int __TVOS_15_4() {
        return __TVOS_15_4;
    }
    private static final int __TVOS_15_5 = (int)150500L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_5 150500
     * }
     */
    public static int __TVOS_15_5() {
        return __TVOS_15_5;
    }
    private static final int __TVOS_15_6 = (int)150600L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_6 150600
     * }
     */
    public static int __TVOS_15_6() {
        return __TVOS_15_6;
    }
    private static final int __TVOS_16_0 = (int)160000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_0 160000
     * }
     */
    public static int __TVOS_16_0() {
        return __TVOS_16_0;
    }
    private static final int __TVOS_16_1 = (int)160100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_1 160100
     * }
     */
    public static int __TVOS_16_1() {
        return __TVOS_16_1;
    }
    private static final int __TVOS_16_2 = (int)160200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_2 160200
     * }
     */
    public static int __TVOS_16_2() {
        return __TVOS_16_2;
    }
    private static final int __TVOS_16_3 = (int)160300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_3 160300
     * }
     */
    public static int __TVOS_16_3() {
        return __TVOS_16_3;
    }
    private static final int __TVOS_16_4 = (int)160400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_4 160400
     * }
     */
    public static int __TVOS_16_4() {
        return __TVOS_16_4;
    }
    private static final int __TVOS_16_5 = (int)160500L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_5 160500
     * }
     */
    public static int __TVOS_16_5() {
        return __TVOS_16_5;
    }
    private static final int __TVOS_16_6 = (int)160600L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_6 160600
     * }
     */
    public static int __TVOS_16_6() {
        return __TVOS_16_6;
    }
    private static final int __TVOS_17_0 = (int)170000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_0 170000
     * }
     */
    public static int __TVOS_17_0() {
        return __TVOS_17_0;
    }
    private static final int __TVOS_17_1 = (int)170100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_1 170100
     * }
     */
    public static int __TVOS_17_1() {
        return __TVOS_17_1;
    }
    private static final int __TVOS_17_2 = (int)170200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_2 170200
     * }
     */
    public static int __TVOS_17_2() {
        return __TVOS_17_2;
    }
    private static final int __TVOS_17_3 = (int)170300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_3 170300
     * }
     */
    public static int __TVOS_17_3() {
        return __TVOS_17_3;
    }
    private static final int __TVOS_17_4 = (int)170400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_4 170400
     * }
     */
    public static int __TVOS_17_4() {
        return __TVOS_17_4;
    }
    private static final int __TVOS_17_5 = (int)170500L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_5 170500
     * }
     */
    public static int __TVOS_17_5() {
        return __TVOS_17_5;
    }
    private static final int __TVOS_18_0 = (int)180000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_18_0 180000
     * }
     */
    public static int __TVOS_18_0() {
        return __TVOS_18_0;
    }
    private static final int __TVOS_18_1 = (int)180100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_18_1 180100
     * }
     */
    public static int __TVOS_18_1() {
        return __TVOS_18_1;
    }
    private static final int __TVOS_18_2 = (int)180200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_18_2 180200
     * }
     */
    public static int __TVOS_18_2() {
        return __TVOS_18_2;
    }
    private static final int __BRIDGEOS_2_0 = (int)20000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_2_0 20000
     * }
     */
    public static int __BRIDGEOS_2_0() {
        return __BRIDGEOS_2_0;
    }
    private static final int __BRIDGEOS_3_0 = (int)30000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_3_0 30000
     * }
     */
    public static int __BRIDGEOS_3_0() {
        return __BRIDGEOS_3_0;
    }
    private static final int __BRIDGEOS_3_1 = (int)30100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_3_1 30100
     * }
     */
    public static int __BRIDGEOS_3_1() {
        return __BRIDGEOS_3_1;
    }
    private static final int __BRIDGEOS_3_4 = (int)30400L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_3_4 30400
     * }
     */
    public static int __BRIDGEOS_3_4() {
        return __BRIDGEOS_3_4;
    }
    private static final int __BRIDGEOS_4_0 = (int)40000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_4_0 40000
     * }
     */
    public static int __BRIDGEOS_4_0() {
        return __BRIDGEOS_4_0;
    }
    private static final int __BRIDGEOS_4_1 = (int)40100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_4_1 40100
     * }
     */
    public static int __BRIDGEOS_4_1() {
        return __BRIDGEOS_4_1;
    }
    private static final int __BRIDGEOS_5_0 = (int)50000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_5_0 50000
     * }
     */
    public static int __BRIDGEOS_5_0() {
        return __BRIDGEOS_5_0;
    }
    private static final int __BRIDGEOS_5_1 = (int)50100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_5_1 50100
     * }
     */
    public static int __BRIDGEOS_5_1() {
        return __BRIDGEOS_5_1;
    }
    private static final int __BRIDGEOS_5_3 = (int)50300L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_5_3 50300
     * }
     */
    public static int __BRIDGEOS_5_3() {
        return __BRIDGEOS_5_3;
    }
    private static final int __BRIDGEOS_6_0 = (int)60000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_0 60000
     * }
     */
    public static int __BRIDGEOS_6_0() {
        return __BRIDGEOS_6_0;
    }
    private static final int __BRIDGEOS_6_2 = (int)60200L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_2 60200
     * }
     */
    public static int __BRIDGEOS_6_2() {
        return __BRIDGEOS_6_2;
    }
    private static final int __BRIDGEOS_6_4 = (int)60400L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_4 60400
     * }
     */
    public static int __BRIDGEOS_6_4() {
        return __BRIDGEOS_6_4;
    }
    private static final int __BRIDGEOS_6_5 = (int)60500L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_5 60500
     * }
     */
    public static int __BRIDGEOS_6_5() {
        return __BRIDGEOS_6_5;
    }
    private static final int __BRIDGEOS_6_6 = (int)60600L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_6 60600
     * }
     */
    public static int __BRIDGEOS_6_6() {
        return __BRIDGEOS_6_6;
    }
    private static final int __BRIDGEOS_7_0 = (int)70000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_0 70000
     * }
     */
    public static int __BRIDGEOS_7_0() {
        return __BRIDGEOS_7_0;
    }
    private static final int __BRIDGEOS_7_1 = (int)70100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_1 70100
     * }
     */
    public static int __BRIDGEOS_7_1() {
        return __BRIDGEOS_7_1;
    }
    private static final int __BRIDGEOS_7_2 = (int)70200L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_2 70200
     * }
     */
    public static int __BRIDGEOS_7_2() {
        return __BRIDGEOS_7_2;
    }
    private static final int __BRIDGEOS_7_3 = (int)70300L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_3 70300
     * }
     */
    public static int __BRIDGEOS_7_3() {
        return __BRIDGEOS_7_3;
    }
    private static final int __BRIDGEOS_7_4 = (int)70400L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_4 70400
     * }
     */
    public static int __BRIDGEOS_7_4() {
        return __BRIDGEOS_7_4;
    }
    private static final int __BRIDGEOS_7_6 = (int)70600L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_6 70600
     * }
     */
    public static int __BRIDGEOS_7_6() {
        return __BRIDGEOS_7_6;
    }
    private static final int __BRIDGEOS_8_0 = (int)80000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_0 80000
     * }
     */
    public static int __BRIDGEOS_8_0() {
        return __BRIDGEOS_8_0;
    }
    private static final int __BRIDGEOS_8_1 = (int)80100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_1 80100
     * }
     */
    public static int __BRIDGEOS_8_1() {
        return __BRIDGEOS_8_1;
    }
    private static final int __BRIDGEOS_8_2 = (int)80200L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_2 80200
     * }
     */
    public static int __BRIDGEOS_8_2() {
        return __BRIDGEOS_8_2;
    }
    private static final int __BRIDGEOS_8_3 = (int)80300L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_3 80300
     * }
     */
    public static int __BRIDGEOS_8_3() {
        return __BRIDGEOS_8_3;
    }
    private static final int __BRIDGEOS_8_4 = (int)80400L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_4 80400
     * }
     */
    public static int __BRIDGEOS_8_4() {
        return __BRIDGEOS_8_4;
    }
    private static final int __BRIDGEOS_8_5 = (int)80500L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_5 80500
     * }
     */
    public static int __BRIDGEOS_8_5() {
        return __BRIDGEOS_8_5;
    }
    private static final int __BRIDGEOS_9_0 = (int)90000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_9_0 90000
     * }
     */
    public static int __BRIDGEOS_9_0() {
        return __BRIDGEOS_9_0;
    }
    private static final int __BRIDGEOS_9_1 = (int)90100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_9_1 90100
     * }
     */
    public static int __BRIDGEOS_9_1() {
        return __BRIDGEOS_9_1;
    }
    private static final int __BRIDGEOS_9_2 = (int)90200L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_9_2 90200
     * }
     */
    public static int __BRIDGEOS_9_2() {
        return __BRIDGEOS_9_2;
    }
    private static final int __DRIVERKIT_19_0 = (int)190000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_19_0 190000
     * }
     */
    public static int __DRIVERKIT_19_0() {
        return __DRIVERKIT_19_0;
    }
    private static final int __DRIVERKIT_20_0 = (int)200000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_20_0 200000
     * }
     */
    public static int __DRIVERKIT_20_0() {
        return __DRIVERKIT_20_0;
    }
    private static final int __DRIVERKIT_21_0 = (int)210000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_21_0 210000
     * }
     */
    public static int __DRIVERKIT_21_0() {
        return __DRIVERKIT_21_0;
    }
    private static final int __DRIVERKIT_22_0 = (int)220000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_22_0 220000
     * }
     */
    public static int __DRIVERKIT_22_0() {
        return __DRIVERKIT_22_0;
    }
    private static final int __DRIVERKIT_22_4 = (int)220400L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_22_4 220400
     * }
     */
    public static int __DRIVERKIT_22_4() {
        return __DRIVERKIT_22_4;
    }
    private static final int __DRIVERKIT_22_5 = (int)220500L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_22_5 220500
     * }
     */
    public static int __DRIVERKIT_22_5() {
        return __DRIVERKIT_22_5;
    }
    private static final int __DRIVERKIT_22_6 = (int)220600L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_22_6 220600
     * }
     */
    public static int __DRIVERKIT_22_6() {
        return __DRIVERKIT_22_6;
    }
    private static final int __DRIVERKIT_23_0 = (int)230000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_0 230000
     * }
     */
    public static int __DRIVERKIT_23_0() {
        return __DRIVERKIT_23_0;
    }
    private static final int __DRIVERKIT_23_1 = (int)230100L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_1 230100
     * }
     */
    public static int __DRIVERKIT_23_1() {
        return __DRIVERKIT_23_1;
    }
    private static final int __DRIVERKIT_23_2 = (int)230200L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_2 230200
     * }
     */
    public static int __DRIVERKIT_23_2() {
        return __DRIVERKIT_23_2;
    }
    private static final int __DRIVERKIT_23_3 = (int)230300L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_3 230300
     * }
     */
    public static int __DRIVERKIT_23_3() {
        return __DRIVERKIT_23_3;
    }
    private static final int __DRIVERKIT_23_4 = (int)230400L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_4 230400
     * }
     */
    public static int __DRIVERKIT_23_4() {
        return __DRIVERKIT_23_4;
    }
    private static final int __DRIVERKIT_23_5 = (int)230500L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_5 230500
     * }
     */
    public static int __DRIVERKIT_23_5() {
        return __DRIVERKIT_23_5;
    }
    private static final int __DRIVERKIT_24_0 = (int)240000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_24_0 240000
     * }
     */
    public static int __DRIVERKIT_24_0() {
        return __DRIVERKIT_24_0;
    }
    private static final int __DRIVERKIT_24_1 = (int)240100L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_24_1 240100
     * }
     */
    public static int __DRIVERKIT_24_1() {
        return __DRIVERKIT_24_1;
    }
    private static final int __DRIVERKIT_24_2 = (int)240200L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_24_2 240200
     * }
     */
    public static int __DRIVERKIT_24_2() {
        return __DRIVERKIT_24_2;
    }
    private static final int __VISIONOS_1_0 = (int)10000L;
    /**
     * {@snippet lang=c :
     * #define __VISIONOS_1_0 10000
     * }
     */
    public static int __VISIONOS_1_0() {
        return __VISIONOS_1_0;
    }
    private static final int __VISIONOS_1_1 = (int)10100L;
    /**
     * {@snippet lang=c :
     * #define __VISIONOS_1_1 10100
     * }
     */
    public static int __VISIONOS_1_1() {
        return __VISIONOS_1_1;
    }
    private static final int __VISIONOS_1_2 = (int)10200L;
    /**
     * {@snippet lang=c :
     * #define __VISIONOS_1_2 10200
     * }
     */
    public static int __VISIONOS_1_2() {
        return __VISIONOS_1_2;
    }
    private static final int __VISIONOS_2_0 = (int)20000L;
    /**
     * {@snippet lang=c :
     * #define __VISIONOS_2_0 20000
     * }
     */
    public static int __VISIONOS_2_0() {
        return __VISIONOS_2_0;
    }
    private static final int __VISIONOS_2_1 = (int)20100L;
    /**
     * {@snippet lang=c :
     * #define __VISIONOS_2_1 20100
     * }
     */
    public static int __VISIONOS_2_1() {
        return __VISIONOS_2_1;
    }
    private static final int __VISIONOS_2_2 = (int)20200L;
    /**
     * {@snippet lang=c :
     * #define __VISIONOS_2_2 20200
     * }
     */
    public static int __VISIONOS_2_2() {
        return __VISIONOS_2_2;
    }
    private static final int __ENABLE_LEGACY_MAC_AVAILABILITY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __ENABLE_LEGACY_MAC_AVAILABILITY 1
     * }
     */
    public static int __ENABLE_LEGACY_MAC_AVAILABILITY() {
        return __ENABLE_LEGACY_MAC_AVAILABILITY;
    }
    private static final int STDIN_FILENO = (int)0L;
    /**
     * {@snippet lang=c :
     * #define STDIN_FILENO 0
     * }
     */
    public static int STDIN_FILENO() {
        return STDIN_FILENO;
    }
    private static final int STDOUT_FILENO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define STDOUT_FILENO 1
     * }
     */
    public static int STDOUT_FILENO() {
        return STDOUT_FILENO;
    }
    private static final int STDERR_FILENO = (int)2L;
    /**
     * {@snippet lang=c :
     * #define STDERR_FILENO 2
     * }
     */
    public static int STDERR_FILENO() {
        return STDERR_FILENO;
    }
    private static final int _XOPEN_VERSION = (int)600L;
    /**
     * {@snippet lang=c :
     * #define _XOPEN_VERSION 600
     * }
     */
    public static int _XOPEN_VERSION() {
        return _XOPEN_VERSION;
    }
    private static final int _XOPEN_XCU_VERSION = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _XOPEN_XCU_VERSION 4
     * }
     */
    public static int _XOPEN_XCU_VERSION() {
        return _XOPEN_XCU_VERSION;
    }
    private static final int _SC_ARG_MAX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SC_ARG_MAX 1
     * }
     */
    public static int _SC_ARG_MAX() {
        return _SC_ARG_MAX;
    }
    private static final int _SC_CHILD_MAX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _SC_CHILD_MAX 2
     * }
     */
    public static int _SC_CHILD_MAX() {
        return _SC_CHILD_MAX;
    }
    private static final int _SC_CLK_TCK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _SC_CLK_TCK 3
     * }
     */
    public static int _SC_CLK_TCK() {
        return _SC_CLK_TCK;
    }
    private static final int _SC_NGROUPS_MAX = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _SC_NGROUPS_MAX 4
     * }
     */
    public static int _SC_NGROUPS_MAX() {
        return _SC_NGROUPS_MAX;
    }
    private static final int _SC_OPEN_MAX = (int)5L;
    /**
     * {@snippet lang=c :
     * #define _SC_OPEN_MAX 5
     * }
     */
    public static int _SC_OPEN_MAX() {
        return _SC_OPEN_MAX;
    }
    private static final int _SC_JOB_CONTROL = (int)6L;
    /**
     * {@snippet lang=c :
     * #define _SC_JOB_CONTROL 6
     * }
     */
    public static int _SC_JOB_CONTROL() {
        return _SC_JOB_CONTROL;
    }
    private static final int _SC_SAVED_IDS = (int)7L;
    /**
     * {@snippet lang=c :
     * #define _SC_SAVED_IDS 7
     * }
     */
    public static int _SC_SAVED_IDS() {
        return _SC_SAVED_IDS;
    }
    private static final int _SC_VERSION = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _SC_VERSION 8
     * }
     */
    public static int _SC_VERSION() {
        return _SC_VERSION;
    }
    private static final int _SC_BC_BASE_MAX = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _SC_BC_BASE_MAX 9
     * }
     */
    public static int _SC_BC_BASE_MAX() {
        return _SC_BC_BASE_MAX;
    }
    private static final int _SC_BC_DIM_MAX = (int)10L;
    /**
     * {@snippet lang=c :
     * #define _SC_BC_DIM_MAX 10
     * }
     */
    public static int _SC_BC_DIM_MAX() {
        return _SC_BC_DIM_MAX;
    }
    private static final int _SC_BC_SCALE_MAX = (int)11L;
    /**
     * {@snippet lang=c :
     * #define _SC_BC_SCALE_MAX 11
     * }
     */
    public static int _SC_BC_SCALE_MAX() {
        return _SC_BC_SCALE_MAX;
    }
    private static final int _SC_BC_STRING_MAX = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _SC_BC_STRING_MAX 12
     * }
     */
    public static int _SC_BC_STRING_MAX() {
        return _SC_BC_STRING_MAX;
    }
    private static final int _SC_COLL_WEIGHTS_MAX = (int)13L;
    /**
     * {@snippet lang=c :
     * #define _SC_COLL_WEIGHTS_MAX 13
     * }
     */
    public static int _SC_COLL_WEIGHTS_MAX() {
        return _SC_COLL_WEIGHTS_MAX;
    }
    private static final int _SC_EXPR_NEST_MAX = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _SC_EXPR_NEST_MAX 14
     * }
     */
    public static int _SC_EXPR_NEST_MAX() {
        return _SC_EXPR_NEST_MAX;
    }
    private static final int _SC_LINE_MAX = (int)15L;
    /**
     * {@snippet lang=c :
     * #define _SC_LINE_MAX 15
     * }
     */
    public static int _SC_LINE_MAX() {
        return _SC_LINE_MAX;
    }
    private static final int _SC_RE_DUP_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _SC_RE_DUP_MAX 16
     * }
     */
    public static int _SC_RE_DUP_MAX() {
        return _SC_RE_DUP_MAX;
    }
    private static final int _SC_2_VERSION = (int)17L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_VERSION 17
     * }
     */
    public static int _SC_2_VERSION() {
        return _SC_2_VERSION;
    }
    private static final int _SC_2_C_BIND = (int)18L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_C_BIND 18
     * }
     */
    public static int _SC_2_C_BIND() {
        return _SC_2_C_BIND;
    }
    private static final int _SC_2_C_DEV = (int)19L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_C_DEV 19
     * }
     */
    public static int _SC_2_C_DEV() {
        return _SC_2_C_DEV;
    }
    private static final int _SC_2_CHAR_TERM = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_CHAR_TERM 20
     * }
     */
    public static int _SC_2_CHAR_TERM() {
        return _SC_2_CHAR_TERM;
    }
    private static final int _SC_2_FORT_DEV = (int)21L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_FORT_DEV 21
     * }
     */
    public static int _SC_2_FORT_DEV() {
        return _SC_2_FORT_DEV;
    }
    private static final int _SC_2_FORT_RUN = (int)22L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_FORT_RUN 22
     * }
     */
    public static int _SC_2_FORT_RUN() {
        return _SC_2_FORT_RUN;
    }
    private static final int _SC_2_LOCALEDEF = (int)23L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_LOCALEDEF 23
     * }
     */
    public static int _SC_2_LOCALEDEF() {
        return _SC_2_LOCALEDEF;
    }
    private static final int _SC_2_SW_DEV = (int)24L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_SW_DEV 24
     * }
     */
    public static int _SC_2_SW_DEV() {
        return _SC_2_SW_DEV;
    }
    private static final int _SC_2_UPE = (int)25L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_UPE 25
     * }
     */
    public static int _SC_2_UPE() {
        return _SC_2_UPE;
    }
    private static final int _SC_STREAM_MAX = (int)26L;
    /**
     * {@snippet lang=c :
     * #define _SC_STREAM_MAX 26
     * }
     */
    public static int _SC_STREAM_MAX() {
        return _SC_STREAM_MAX;
    }
    private static final int _SC_TZNAME_MAX = (int)27L;
    /**
     * {@snippet lang=c :
     * #define _SC_TZNAME_MAX 27
     * }
     */
    public static int _SC_TZNAME_MAX() {
        return _SC_TZNAME_MAX;
    }
    private static final int _SC_ASYNCHRONOUS_IO = (int)28L;
    /**
     * {@snippet lang=c :
     * #define _SC_ASYNCHRONOUS_IO 28
     * }
     */
    public static int _SC_ASYNCHRONOUS_IO() {
        return _SC_ASYNCHRONOUS_IO;
    }
    private static final int _SC_PAGESIZE = (int)29L;
    /**
     * {@snippet lang=c :
     * #define _SC_PAGESIZE 29
     * }
     */
    public static int _SC_PAGESIZE() {
        return _SC_PAGESIZE;
    }
    private static final int _SC_MEMLOCK = (int)30L;
    /**
     * {@snippet lang=c :
     * #define _SC_MEMLOCK 30
     * }
     */
    public static int _SC_MEMLOCK() {
        return _SC_MEMLOCK;
    }
    private static final int _SC_MEMLOCK_RANGE = (int)31L;
    /**
     * {@snippet lang=c :
     * #define _SC_MEMLOCK_RANGE 31
     * }
     */
    public static int _SC_MEMLOCK_RANGE() {
        return _SC_MEMLOCK_RANGE;
    }
    private static final int _SC_MEMORY_PROTECTION = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _SC_MEMORY_PROTECTION 32
     * }
     */
    public static int _SC_MEMORY_PROTECTION() {
        return _SC_MEMORY_PROTECTION;
    }
    private static final int _SC_MESSAGE_PASSING = (int)33L;
    /**
     * {@snippet lang=c :
     * #define _SC_MESSAGE_PASSING 33
     * }
     */
    public static int _SC_MESSAGE_PASSING() {
        return _SC_MESSAGE_PASSING;
    }
    private static final int _SC_PRIORITIZED_IO = (int)34L;
    /**
     * {@snippet lang=c :
     * #define _SC_PRIORITIZED_IO 34
     * }
     */
    public static int _SC_PRIORITIZED_IO() {
        return _SC_PRIORITIZED_IO;
    }
    private static final int _SC_PRIORITY_SCHEDULING = (int)35L;
    /**
     * {@snippet lang=c :
     * #define _SC_PRIORITY_SCHEDULING 35
     * }
     */
    public static int _SC_PRIORITY_SCHEDULING() {
        return _SC_PRIORITY_SCHEDULING;
    }
    private static final int _SC_REALTIME_SIGNALS = (int)36L;
    /**
     * {@snippet lang=c :
     * #define _SC_REALTIME_SIGNALS 36
     * }
     */
    public static int _SC_REALTIME_SIGNALS() {
        return _SC_REALTIME_SIGNALS;
    }
    private static final int _SC_SEMAPHORES = (int)37L;
    /**
     * {@snippet lang=c :
     * #define _SC_SEMAPHORES 37
     * }
     */
    public static int _SC_SEMAPHORES() {
        return _SC_SEMAPHORES;
    }
    private static final int _SC_FSYNC = (int)38L;
    /**
     * {@snippet lang=c :
     * #define _SC_FSYNC 38
     * }
     */
    public static int _SC_FSYNC() {
        return _SC_FSYNC;
    }
    private static final int _SC_SHARED_MEMORY_OBJECTS = (int)39L;
    /**
     * {@snippet lang=c :
     * #define _SC_SHARED_MEMORY_OBJECTS 39
     * }
     */
    public static int _SC_SHARED_MEMORY_OBJECTS() {
        return _SC_SHARED_MEMORY_OBJECTS;
    }
    private static final int _SC_SYNCHRONIZED_IO = (int)40L;
    /**
     * {@snippet lang=c :
     * #define _SC_SYNCHRONIZED_IO 40
     * }
     */
    public static int _SC_SYNCHRONIZED_IO() {
        return _SC_SYNCHRONIZED_IO;
    }
    private static final int _SC_TIMERS = (int)41L;
    /**
     * {@snippet lang=c :
     * #define _SC_TIMERS 41
     * }
     */
    public static int _SC_TIMERS() {
        return _SC_TIMERS;
    }
    private static final int _SC_AIO_LISTIO_MAX = (int)42L;
    /**
     * {@snippet lang=c :
     * #define _SC_AIO_LISTIO_MAX 42
     * }
     */
    public static int _SC_AIO_LISTIO_MAX() {
        return _SC_AIO_LISTIO_MAX;
    }
    private static final int _SC_AIO_MAX = (int)43L;
    /**
     * {@snippet lang=c :
     * #define _SC_AIO_MAX 43
     * }
     */
    public static int _SC_AIO_MAX() {
        return _SC_AIO_MAX;
    }
    private static final int _SC_AIO_PRIO_DELTA_MAX = (int)44L;
    /**
     * {@snippet lang=c :
     * #define _SC_AIO_PRIO_DELTA_MAX 44
     * }
     */
    public static int _SC_AIO_PRIO_DELTA_MAX() {
        return _SC_AIO_PRIO_DELTA_MAX;
    }
    private static final int _SC_DELAYTIMER_MAX = (int)45L;
    /**
     * {@snippet lang=c :
     * #define _SC_DELAYTIMER_MAX 45
     * }
     */
    public static int _SC_DELAYTIMER_MAX() {
        return _SC_DELAYTIMER_MAX;
    }
    private static final int _SC_MQ_OPEN_MAX = (int)46L;
    /**
     * {@snippet lang=c :
     * #define _SC_MQ_OPEN_MAX 46
     * }
     */
    public static int _SC_MQ_OPEN_MAX() {
        return _SC_MQ_OPEN_MAX;
    }
    private static final int _SC_MAPPED_FILES = (int)47L;
    /**
     * {@snippet lang=c :
     * #define _SC_MAPPED_FILES 47
     * }
     */
    public static int _SC_MAPPED_FILES() {
        return _SC_MAPPED_FILES;
    }
    private static final int _SC_RTSIG_MAX = (int)48L;
    /**
     * {@snippet lang=c :
     * #define _SC_RTSIG_MAX 48
     * }
     */
    public static int _SC_RTSIG_MAX() {
        return _SC_RTSIG_MAX;
    }
    private static final int _SC_SEM_NSEMS_MAX = (int)49L;
    /**
     * {@snippet lang=c :
     * #define _SC_SEM_NSEMS_MAX 49
     * }
     */
    public static int _SC_SEM_NSEMS_MAX() {
        return _SC_SEM_NSEMS_MAX;
    }
    private static final int _SC_SEM_VALUE_MAX = (int)50L;
    /**
     * {@snippet lang=c :
     * #define _SC_SEM_VALUE_MAX 50
     * }
     */
    public static int _SC_SEM_VALUE_MAX() {
        return _SC_SEM_VALUE_MAX;
    }
    private static final int _SC_SIGQUEUE_MAX = (int)51L;
    /**
     * {@snippet lang=c :
     * #define _SC_SIGQUEUE_MAX 51
     * }
     */
    public static int _SC_SIGQUEUE_MAX() {
        return _SC_SIGQUEUE_MAX;
    }
    private static final int _SC_TIMER_MAX = (int)52L;
    /**
     * {@snippet lang=c :
     * #define _SC_TIMER_MAX 52
     * }
     */
    public static int _SC_TIMER_MAX() {
        return _SC_TIMER_MAX;
    }
    private static final int _SC_NPROCESSORS_CONF = (int)57L;
    /**
     * {@snippet lang=c :
     * #define _SC_NPROCESSORS_CONF 57
     * }
     */
    public static int _SC_NPROCESSORS_CONF() {
        return _SC_NPROCESSORS_CONF;
    }
    private static final int _SC_NPROCESSORS_ONLN = (int)58L;
    /**
     * {@snippet lang=c :
     * #define _SC_NPROCESSORS_ONLN 58
     * }
     */
    public static int _SC_NPROCESSORS_ONLN() {
        return _SC_NPROCESSORS_ONLN;
    }
    private static final int _SC_2_PBS = (int)59L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS 59
     * }
     */
    public static int _SC_2_PBS() {
        return _SC_2_PBS;
    }
    private static final int _SC_2_PBS_ACCOUNTING = (int)60L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS_ACCOUNTING 60
     * }
     */
    public static int _SC_2_PBS_ACCOUNTING() {
        return _SC_2_PBS_ACCOUNTING;
    }
    private static final int _SC_2_PBS_CHECKPOINT = (int)61L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS_CHECKPOINT 61
     * }
     */
    public static int _SC_2_PBS_CHECKPOINT() {
        return _SC_2_PBS_CHECKPOINT;
    }
    private static final int _SC_2_PBS_LOCATE = (int)62L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS_LOCATE 62
     * }
     */
    public static int _SC_2_PBS_LOCATE() {
        return _SC_2_PBS_LOCATE;
    }
    private static final int _SC_2_PBS_MESSAGE = (int)63L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS_MESSAGE 63
     * }
     */
    public static int _SC_2_PBS_MESSAGE() {
        return _SC_2_PBS_MESSAGE;
    }
    private static final int _SC_2_PBS_TRACK = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS_TRACK 64
     * }
     */
    public static int _SC_2_PBS_TRACK() {
        return _SC_2_PBS_TRACK;
    }
    private static final int _SC_ADVISORY_INFO = (int)65L;
    /**
     * {@snippet lang=c :
     * #define _SC_ADVISORY_INFO 65
     * }
     */
    public static int _SC_ADVISORY_INFO() {
        return _SC_ADVISORY_INFO;
    }
    private static final int _SC_BARRIERS = (int)66L;
    /**
     * {@snippet lang=c :
     * #define _SC_BARRIERS 66
     * }
     */
    public static int _SC_BARRIERS() {
        return _SC_BARRIERS;
    }
    private static final int _SC_CLOCK_SELECTION = (int)67L;
    /**
     * {@snippet lang=c :
     * #define _SC_CLOCK_SELECTION 67
     * }
     */
    public static int _SC_CLOCK_SELECTION() {
        return _SC_CLOCK_SELECTION;
    }
    private static final int _SC_CPUTIME = (int)68L;
    /**
     * {@snippet lang=c :
     * #define _SC_CPUTIME 68
     * }
     */
    public static int _SC_CPUTIME() {
        return _SC_CPUTIME;
    }
    private static final int _SC_FILE_LOCKING = (int)69L;
    /**
     * {@snippet lang=c :
     * #define _SC_FILE_LOCKING 69
     * }
     */
    public static int _SC_FILE_LOCKING() {
        return _SC_FILE_LOCKING;
    }
    private static final int _SC_GETGR_R_SIZE_MAX = (int)70L;
    /**
     * {@snippet lang=c :
     * #define _SC_GETGR_R_SIZE_MAX 70
     * }
     */
    public static int _SC_GETGR_R_SIZE_MAX() {
        return _SC_GETGR_R_SIZE_MAX;
    }
    private static final int _SC_GETPW_R_SIZE_MAX = (int)71L;
    /**
     * {@snippet lang=c :
     * #define _SC_GETPW_R_SIZE_MAX 71
     * }
     */
    public static int _SC_GETPW_R_SIZE_MAX() {
        return _SC_GETPW_R_SIZE_MAX;
    }
    private static final int _SC_HOST_NAME_MAX = (int)72L;
    /**
     * {@snippet lang=c :
     * #define _SC_HOST_NAME_MAX 72
     * }
     */
    public static int _SC_HOST_NAME_MAX() {
        return _SC_HOST_NAME_MAX;
    }
    private static final int _SC_LOGIN_NAME_MAX = (int)73L;
    /**
     * {@snippet lang=c :
     * #define _SC_LOGIN_NAME_MAX 73
     * }
     */
    public static int _SC_LOGIN_NAME_MAX() {
        return _SC_LOGIN_NAME_MAX;
    }
    private static final int _SC_MONOTONIC_CLOCK = (int)74L;
    /**
     * {@snippet lang=c :
     * #define _SC_MONOTONIC_CLOCK 74
     * }
     */
    public static int _SC_MONOTONIC_CLOCK() {
        return _SC_MONOTONIC_CLOCK;
    }
    private static final int _SC_MQ_PRIO_MAX = (int)75L;
    /**
     * {@snippet lang=c :
     * #define _SC_MQ_PRIO_MAX 75
     * }
     */
    public static int _SC_MQ_PRIO_MAX() {
        return _SC_MQ_PRIO_MAX;
    }
    private static final int _SC_READER_WRITER_LOCKS = (int)76L;
    /**
     * {@snippet lang=c :
     * #define _SC_READER_WRITER_LOCKS 76
     * }
     */
    public static int _SC_READER_WRITER_LOCKS() {
        return _SC_READER_WRITER_LOCKS;
    }
    private static final int _SC_REGEXP = (int)77L;
    /**
     * {@snippet lang=c :
     * #define _SC_REGEXP 77
     * }
     */
    public static int _SC_REGEXP() {
        return _SC_REGEXP;
    }
    private static final int _SC_SHELL = (int)78L;
    /**
     * {@snippet lang=c :
     * #define _SC_SHELL 78
     * }
     */
    public static int _SC_SHELL() {
        return _SC_SHELL;
    }
    private static final int _SC_SPAWN = (int)79L;
    /**
     * {@snippet lang=c :
     * #define _SC_SPAWN 79
     * }
     */
    public static int _SC_SPAWN() {
        return _SC_SPAWN;
    }
    private static final int _SC_SPIN_LOCKS = (int)80L;
    /**
     * {@snippet lang=c :
     * #define _SC_SPIN_LOCKS 80
     * }
     */
    public static int _SC_SPIN_LOCKS() {
        return _SC_SPIN_LOCKS;
    }
    private static final int _SC_SPORADIC_SERVER = (int)81L;
    /**
     * {@snippet lang=c :
     * #define _SC_SPORADIC_SERVER 81
     * }
     */
    public static int _SC_SPORADIC_SERVER() {
        return _SC_SPORADIC_SERVER;
    }
    private static final int _SC_THREAD_ATTR_STACKADDR = (int)82L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_ATTR_STACKADDR 82
     * }
     */
    public static int _SC_THREAD_ATTR_STACKADDR() {
        return _SC_THREAD_ATTR_STACKADDR;
    }
    private static final int _SC_THREAD_ATTR_STACKSIZE = (int)83L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_ATTR_STACKSIZE 83
     * }
     */
    public static int _SC_THREAD_ATTR_STACKSIZE() {
        return _SC_THREAD_ATTR_STACKSIZE;
    }
    private static final int _SC_THREAD_CPUTIME = (int)84L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_CPUTIME 84
     * }
     */
    public static int _SC_THREAD_CPUTIME() {
        return _SC_THREAD_CPUTIME;
    }
    private static final int _SC_THREAD_DESTRUCTOR_ITERATIONS = (int)85L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_DESTRUCTOR_ITERATIONS 85
     * }
     */
    public static int _SC_THREAD_DESTRUCTOR_ITERATIONS() {
        return _SC_THREAD_DESTRUCTOR_ITERATIONS;
    }
    private static final int _SC_THREAD_KEYS_MAX = (int)86L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_KEYS_MAX 86
     * }
     */
    public static int _SC_THREAD_KEYS_MAX() {
        return _SC_THREAD_KEYS_MAX;
    }
    private static final int _SC_THREAD_PRIO_INHERIT = (int)87L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_PRIO_INHERIT 87
     * }
     */
    public static int _SC_THREAD_PRIO_INHERIT() {
        return _SC_THREAD_PRIO_INHERIT;
    }
    private static final int _SC_THREAD_PRIO_PROTECT = (int)88L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_PRIO_PROTECT 88
     * }
     */
    public static int _SC_THREAD_PRIO_PROTECT() {
        return _SC_THREAD_PRIO_PROTECT;
    }
    private static final int _SC_THREAD_PRIORITY_SCHEDULING = (int)89L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_PRIORITY_SCHEDULING 89
     * }
     */
    public static int _SC_THREAD_PRIORITY_SCHEDULING() {
        return _SC_THREAD_PRIORITY_SCHEDULING;
    }
    private static final int _SC_THREAD_PROCESS_SHARED = (int)90L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_PROCESS_SHARED 90
     * }
     */
    public static int _SC_THREAD_PROCESS_SHARED() {
        return _SC_THREAD_PROCESS_SHARED;
    }
    private static final int _SC_THREAD_SAFE_FUNCTIONS = (int)91L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_SAFE_FUNCTIONS 91
     * }
     */
    public static int _SC_THREAD_SAFE_FUNCTIONS() {
        return _SC_THREAD_SAFE_FUNCTIONS;
    }
    private static final int _SC_THREAD_SPORADIC_SERVER = (int)92L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_SPORADIC_SERVER 92
     * }
     */
    public static int _SC_THREAD_SPORADIC_SERVER() {
        return _SC_THREAD_SPORADIC_SERVER;
    }
    private static final int _SC_THREAD_STACK_MIN = (int)93L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_STACK_MIN 93
     * }
     */
    public static int _SC_THREAD_STACK_MIN() {
        return _SC_THREAD_STACK_MIN;
    }
    private static final int _SC_THREAD_THREADS_MAX = (int)94L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_THREADS_MAX 94
     * }
     */
    public static int _SC_THREAD_THREADS_MAX() {
        return _SC_THREAD_THREADS_MAX;
    }
    private static final int _SC_TIMEOUTS = (int)95L;
    /**
     * {@snippet lang=c :
     * #define _SC_TIMEOUTS 95
     * }
     */
    public static int _SC_TIMEOUTS() {
        return _SC_TIMEOUTS;
    }
    private static final int _SC_THREADS = (int)96L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREADS 96
     * }
     */
    public static int _SC_THREADS() {
        return _SC_THREADS;
    }
    private static final int _SC_TRACE = (int)97L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE 97
     * }
     */
    public static int _SC_TRACE() {
        return _SC_TRACE;
    }
    private static final int _SC_TRACE_EVENT_FILTER = (int)98L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_EVENT_FILTER 98
     * }
     */
    public static int _SC_TRACE_EVENT_FILTER() {
        return _SC_TRACE_EVENT_FILTER;
    }
    private static final int _SC_TRACE_INHERIT = (int)99L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_INHERIT 99
     * }
     */
    public static int _SC_TRACE_INHERIT() {
        return _SC_TRACE_INHERIT;
    }
    private static final int _SC_TRACE_LOG = (int)100L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_LOG 100
     * }
     */
    public static int _SC_TRACE_LOG() {
        return _SC_TRACE_LOG;
    }
    private static final int _SC_TTY_NAME_MAX = (int)101L;
    /**
     * {@snippet lang=c :
     * #define _SC_TTY_NAME_MAX 101
     * }
     */
    public static int _SC_TTY_NAME_MAX() {
        return _SC_TTY_NAME_MAX;
    }
    private static final int _SC_TYPED_MEMORY_OBJECTS = (int)102L;
    /**
     * {@snippet lang=c :
     * #define _SC_TYPED_MEMORY_OBJECTS 102
     * }
     */
    public static int _SC_TYPED_MEMORY_OBJECTS() {
        return _SC_TYPED_MEMORY_OBJECTS;
    }
    private static final int _SC_V6_ILP32_OFF32 = (int)103L;
    /**
     * {@snippet lang=c :
     * #define _SC_V6_ILP32_OFF32 103
     * }
     */
    public static int _SC_V6_ILP32_OFF32() {
        return _SC_V6_ILP32_OFF32;
    }
    private static final int _SC_V6_ILP32_OFFBIG = (int)104L;
    /**
     * {@snippet lang=c :
     * #define _SC_V6_ILP32_OFFBIG 104
     * }
     */
    public static int _SC_V6_ILP32_OFFBIG() {
        return _SC_V6_ILP32_OFFBIG;
    }
    private static final int _SC_V6_LP64_OFF64 = (int)105L;
    /**
     * {@snippet lang=c :
     * #define _SC_V6_LP64_OFF64 105
     * }
     */
    public static int _SC_V6_LP64_OFF64() {
        return _SC_V6_LP64_OFF64;
    }
    private static final int _SC_V6_LPBIG_OFFBIG = (int)106L;
    /**
     * {@snippet lang=c :
     * #define _SC_V6_LPBIG_OFFBIG 106
     * }
     */
    public static int _SC_V6_LPBIG_OFFBIG() {
        return _SC_V6_LPBIG_OFFBIG;
    }
    private static final int _SC_IPV6 = (int)118L;
    /**
     * {@snippet lang=c :
     * #define _SC_IPV6 118
     * }
     */
    public static int _SC_IPV6() {
        return _SC_IPV6;
    }
    private static final int _SC_RAW_SOCKETS = (int)119L;
    /**
     * {@snippet lang=c :
     * #define _SC_RAW_SOCKETS 119
     * }
     */
    public static int _SC_RAW_SOCKETS() {
        return _SC_RAW_SOCKETS;
    }
    private static final int _SC_SYMLOOP_MAX = (int)120L;
    /**
     * {@snippet lang=c :
     * #define _SC_SYMLOOP_MAX 120
     * }
     */
    public static int _SC_SYMLOOP_MAX() {
        return _SC_SYMLOOP_MAX;
    }
    private static final int _SC_ATEXIT_MAX = (int)107L;
    /**
     * {@snippet lang=c :
     * #define _SC_ATEXIT_MAX 107
     * }
     */
    public static int _SC_ATEXIT_MAX() {
        return _SC_ATEXIT_MAX;
    }
    private static final int _SC_IOV_MAX = (int)56L;
    /**
     * {@snippet lang=c :
     * #define _SC_IOV_MAX 56
     * }
     */
    public static int _SC_IOV_MAX() {
        return _SC_IOV_MAX;
    }
    private static final int _SC_XOPEN_CRYPT = (int)108L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_CRYPT 108
     * }
     */
    public static int _SC_XOPEN_CRYPT() {
        return _SC_XOPEN_CRYPT;
    }
    private static final int _SC_XOPEN_ENH_I18N = (int)109L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_ENH_I18N 109
     * }
     */
    public static int _SC_XOPEN_ENH_I18N() {
        return _SC_XOPEN_ENH_I18N;
    }
    private static final int _SC_XOPEN_LEGACY = (int)110L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_LEGACY 110
     * }
     */
    public static int _SC_XOPEN_LEGACY() {
        return _SC_XOPEN_LEGACY;
    }
    private static final int _SC_XOPEN_REALTIME = (int)111L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_REALTIME 111
     * }
     */
    public static int _SC_XOPEN_REALTIME() {
        return _SC_XOPEN_REALTIME;
    }
    private static final int _SC_XOPEN_REALTIME_THREADS = (int)112L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_REALTIME_THREADS 112
     * }
     */
    public static int _SC_XOPEN_REALTIME_THREADS() {
        return _SC_XOPEN_REALTIME_THREADS;
    }
    private static final int _SC_XOPEN_SHM = (int)113L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_SHM 113
     * }
     */
    public static int _SC_XOPEN_SHM() {
        return _SC_XOPEN_SHM;
    }
    private static final int _SC_XOPEN_STREAMS = (int)114L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_STREAMS 114
     * }
     */
    public static int _SC_XOPEN_STREAMS() {
        return _SC_XOPEN_STREAMS;
    }
    private static final int _SC_XOPEN_UNIX = (int)115L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_UNIX 115
     * }
     */
    public static int _SC_XOPEN_UNIX() {
        return _SC_XOPEN_UNIX;
    }
    private static final int _SC_XOPEN_VERSION = (int)116L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_VERSION 116
     * }
     */
    public static int _SC_XOPEN_VERSION() {
        return _SC_XOPEN_VERSION;
    }
    private static final int _SC_XOPEN_XCU_VERSION = (int)121L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_XCU_VERSION 121
     * }
     */
    public static int _SC_XOPEN_XCU_VERSION() {
        return _SC_XOPEN_XCU_VERSION;
    }
    private static final int _SC_XBS5_ILP32_OFF32 = (int)122L;
    /**
     * {@snippet lang=c :
     * #define _SC_XBS5_ILP32_OFF32 122
     * }
     */
    public static int _SC_XBS5_ILP32_OFF32() {
        return _SC_XBS5_ILP32_OFF32;
    }
    private static final int _SC_XBS5_ILP32_OFFBIG = (int)123L;
    /**
     * {@snippet lang=c :
     * #define _SC_XBS5_ILP32_OFFBIG 123
     * }
     */
    public static int _SC_XBS5_ILP32_OFFBIG() {
        return _SC_XBS5_ILP32_OFFBIG;
    }
    private static final int _SC_XBS5_LP64_OFF64 = (int)124L;
    /**
     * {@snippet lang=c :
     * #define _SC_XBS5_LP64_OFF64 124
     * }
     */
    public static int _SC_XBS5_LP64_OFF64() {
        return _SC_XBS5_LP64_OFF64;
    }
    private static final int _SC_XBS5_LPBIG_OFFBIG = (int)125L;
    /**
     * {@snippet lang=c :
     * #define _SC_XBS5_LPBIG_OFFBIG 125
     * }
     */
    public static int _SC_XBS5_LPBIG_OFFBIG() {
        return _SC_XBS5_LPBIG_OFFBIG;
    }
    private static final int _SC_SS_REPL_MAX = (int)126L;
    /**
     * {@snippet lang=c :
     * #define _SC_SS_REPL_MAX 126
     * }
     */
    public static int _SC_SS_REPL_MAX() {
        return _SC_SS_REPL_MAX;
    }
    private static final int _SC_TRACE_EVENT_NAME_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_EVENT_NAME_MAX 127
     * }
     */
    public static int _SC_TRACE_EVENT_NAME_MAX() {
        return _SC_TRACE_EVENT_NAME_MAX;
    }
    private static final int _SC_TRACE_NAME_MAX = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_NAME_MAX 128
     * }
     */
    public static int _SC_TRACE_NAME_MAX() {
        return _SC_TRACE_NAME_MAX;
    }
    private static final int _SC_TRACE_SYS_MAX = (int)129L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_SYS_MAX 129
     * }
     */
    public static int _SC_TRACE_SYS_MAX() {
        return _SC_TRACE_SYS_MAX;
    }
    private static final int _SC_TRACE_USER_EVENT_MAX = (int)130L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_USER_EVENT_MAX 130
     * }
     */
    public static int _SC_TRACE_USER_EVENT_MAX() {
        return _SC_TRACE_USER_EVENT_MAX;
    }
    private static final int _SC_PASS_MAX = (int)131L;
    /**
     * {@snippet lang=c :
     * #define _SC_PASS_MAX 131
     * }
     */
    public static int _SC_PASS_MAX() {
        return _SC_PASS_MAX;
    }
    private static final int _SC_PHYS_PAGES = (int)200L;
    /**
     * {@snippet lang=c :
     * #define _SC_PHYS_PAGES 200
     * }
     */
    public static int _SC_PHYS_PAGES() {
        return _SC_PHYS_PAGES;
    }
    private static final int _CS_POSIX_V6_ILP32_OFF32_CFLAGS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFF32_CFLAGS 2
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFF32_CFLAGS() {
        return _CS_POSIX_V6_ILP32_OFF32_CFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFF32_LDFLAGS 3
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFF32_LDFLAGS() {
        return _CS_POSIX_V6_ILP32_OFF32_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFF32_LIBS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFF32_LIBS 4
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFF32_LIBS() {
        return _CS_POSIX_V6_ILP32_OFF32_LIBS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS 5
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS() {
        return _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = (int)6L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS 6
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS() {
        return _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFFBIG_LIBS = (int)7L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFFBIG_LIBS 7
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFFBIG_LIBS() {
        return _CS_POSIX_V6_ILP32_OFFBIG_LIBS;
    }
    private static final int _CS_POSIX_V6_LP64_OFF64_CFLAGS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LP64_OFF64_CFLAGS 8
     * }
     */
    public static int _CS_POSIX_V6_LP64_OFF64_CFLAGS() {
        return _CS_POSIX_V6_LP64_OFF64_CFLAGS;
    }
    private static final int _CS_POSIX_V6_LP64_OFF64_LDFLAGS = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LP64_OFF64_LDFLAGS 9
     * }
     */
    public static int _CS_POSIX_V6_LP64_OFF64_LDFLAGS() {
        return _CS_POSIX_V6_LP64_OFF64_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_LP64_OFF64_LIBS = (int)10L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LP64_OFF64_LIBS 10
     * }
     */
    public static int _CS_POSIX_V6_LP64_OFF64_LIBS() {
        return _CS_POSIX_V6_LP64_OFF64_LIBS;
    }
    private static final int _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = (int)11L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS 11
     * }
     */
    public static int _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS() {
        return _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS;
    }
    private static final int _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS 12
     * }
     */
    public static int _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS() {
        return _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = (int)13L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LPBIG_OFFBIG_LIBS 13
     * }
     */
    public static int _CS_POSIX_V6_LPBIG_OFFBIG_LIBS() {
        return _CS_POSIX_V6_LPBIG_OFFBIG_LIBS;
    }
    private static final int _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS 14
     * }
     */
    public static int _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS() {
        return _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_CFLAGS = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFF32_CFLAGS 20
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_CFLAGS() {
        return _CS_XBS5_ILP32_OFF32_CFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_LDFLAGS = (int)21L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFF32_LDFLAGS 21
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_LDFLAGS() {
        return _CS_XBS5_ILP32_OFF32_LDFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_LIBS = (int)22L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFF32_LIBS 22
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_LIBS() {
        return _CS_XBS5_ILP32_OFF32_LIBS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_LINTFLAGS = (int)23L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFF32_LINTFLAGS 23
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_LINTFLAGS() {
        return _CS_XBS5_ILP32_OFF32_LINTFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_CFLAGS = (int)24L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFFBIG_CFLAGS 24
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_CFLAGS() {
        return _CS_XBS5_ILP32_OFFBIG_CFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_LDFLAGS = (int)25L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFFBIG_LDFLAGS 25
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_LDFLAGS() {
        return _CS_XBS5_ILP32_OFFBIG_LDFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_LIBS = (int)26L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFFBIG_LIBS 26
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_LIBS() {
        return _CS_XBS5_ILP32_OFFBIG_LIBS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = (int)27L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFFBIG_LINTFLAGS 27
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_LINTFLAGS() {
        return _CS_XBS5_ILP32_OFFBIG_LINTFLAGS;
    }
    private static final int _CS_XBS5_LP64_OFF64_CFLAGS = (int)28L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LP64_OFF64_CFLAGS 28
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_CFLAGS() {
        return _CS_XBS5_LP64_OFF64_CFLAGS;
    }
    private static final int _CS_XBS5_LP64_OFF64_LDFLAGS = (int)29L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LP64_OFF64_LDFLAGS 29
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_LDFLAGS() {
        return _CS_XBS5_LP64_OFF64_LDFLAGS;
    }
    private static final int _CS_XBS5_LP64_OFF64_LIBS = (int)30L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LP64_OFF64_LIBS 30
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_LIBS() {
        return _CS_XBS5_LP64_OFF64_LIBS;
    }
    private static final int _CS_XBS5_LP64_OFF64_LINTFLAGS = (int)31L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LP64_OFF64_LINTFLAGS 31
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_LINTFLAGS() {
        return _CS_XBS5_LP64_OFF64_LINTFLAGS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_CFLAGS = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LPBIG_OFFBIG_CFLAGS 32
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_CFLAGS() {
        return _CS_XBS5_LPBIG_OFFBIG_CFLAGS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = (int)33L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LPBIG_OFFBIG_LDFLAGS 33
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_LDFLAGS() {
        return _CS_XBS5_LPBIG_OFFBIG_LDFLAGS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_LIBS = (int)34L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LPBIG_OFFBIG_LIBS 34
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_LIBS() {
        return _CS_XBS5_LPBIG_OFFBIG_LIBS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = (int)35L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS 35
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS() {
        return _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS;
    }
    private static final int _CS_DARWIN_USER_DIR = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define _CS_DARWIN_USER_DIR 65536
     * }
     */
    public static int _CS_DARWIN_USER_DIR() {
        return _CS_DARWIN_USER_DIR;
    }
    private static final int _CS_DARWIN_USER_TEMP_DIR = (int)65537L;
    /**
     * {@snippet lang=c :
     * #define _CS_DARWIN_USER_TEMP_DIR 65537
     * }
     */
    public static int _CS_DARWIN_USER_TEMP_DIR() {
        return _CS_DARWIN_USER_TEMP_DIR;
    }
    private static final int _CS_DARWIN_USER_CACHE_DIR = (int)65538L;
    /**
     * {@snippet lang=c :
     * #define _CS_DARWIN_USER_CACHE_DIR 65538
     * }
     */
    public static int _CS_DARWIN_USER_CACHE_DIR() {
        return _CS_DARWIN_USER_CACHE_DIR;
    }
    private static final int F_ULOCK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define F_ULOCK 0
     * }
     */
    public static int F_ULOCK() {
        return F_ULOCK;
    }
    private static final int F_LOCK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define F_LOCK 1
     * }
     */
    public static int F_LOCK() {
        return F_LOCK;
    }
    private static final int F_TLOCK = (int)2L;
    /**
     * {@snippet lang=c :
     * #define F_TLOCK 2
     * }
     */
    public static int F_TLOCK() {
        return F_TLOCK;
    }
    private static final int F_TEST = (int)3L;
    /**
     * {@snippet lang=c :
     * #define F_TEST 3
     * }
     */
    public static int F_TEST() {
        return F_TEST;
    }
    private static final int __DARWIN_FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_FD_SETSIZE 1024
     * }
     */
    public static int __DARWIN_FD_SETSIZE() {
        return __DARWIN_FD_SETSIZE;
    }
    private static final int __DARWIN_NBBY = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NBBY 8
     * }
     */
    public static int __DARWIN_NBBY() {
        return __DARWIN_NBBY;
    }
    private static final int SYNC_VOLUME_FULLSYNC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SYNC_VOLUME_FULLSYNC 1
     * }
     */
    public static int SYNC_VOLUME_FULLSYNC() {
        return SYNC_VOLUME_FULLSYNC;
    }
    private static final int SYNC_VOLUME_WAIT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SYNC_VOLUME_WAIT 2
     * }
     */
    public static int SYNC_VOLUME_WAIT() {
        return SYNC_VOLUME_WAIT;
    }
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = unistd_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = unistd_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = unistd_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = unistd_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long __int64_t
     * }
     */
    public static final OfLong __int64_t = unistd_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = unistd_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_intptr_t
     * }
     */
    public static final OfLong __darwin_intptr_t = unistd_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_natural_t
     * }
     */
    public static final OfInt __darwin_natural_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_ct_rune_t
     * }
     */
    public static final OfInt __darwin_ct_rune_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ptrdiff_t
     * }
     */
    public static final OfLong __darwin_ptrdiff_t = unistd_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_size_t
     * }
     */
    public static final OfLong __darwin_size_t = unistd_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wchar_t
     * }
     */
    public static final OfInt __darwin_wchar_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t __darwin_rune_t
     * }
     */
    public static final OfInt __darwin_rune_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wint_t
     * }
     */
    public static final OfInt __darwin_wint_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_clock_t
     * }
     */
    public static final OfLong __darwin_clock_t = unistd_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_socklen_t
     * }
     */
    public static final OfInt __darwin_socklen_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ssize_t
     * }
     */
    public static final OfLong __darwin_ssize_t = unistd_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_time_t
     * }
     */
    public static final OfLong __darwin_time_t = unistd_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_blkcnt_t
     * }
     */
    public static final OfLong __darwin_blkcnt_t = unistd_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_blksize_t
     * }
     */
    public static final OfInt __darwin_blksize_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_dev_t
     * }
     */
    public static final OfInt __darwin_dev_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsblkcnt_t
     * }
     */
    public static final OfInt __darwin_fsblkcnt_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsfilcnt_t
     * }
     */
    public static final OfInt __darwin_fsfilcnt_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_gid_t
     * }
     */
    public static final OfInt __darwin_gid_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_id_t
     * }
     */
    public static final OfInt __darwin_id_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __darwin_ino64_t
     * }
     */
    public static final OfLong __darwin_ino64_t = unistd_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t __darwin_ino_t
     * }
     */
    public static final OfLong __darwin_ino_t = unistd_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_natural_t __darwin_mach_port_name_t
     * }
     */
    public static final OfInt __darwin_mach_port_name_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_name_t __darwin_mach_port_t
     * }
     */
    public static final OfInt __darwin_mach_port_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __darwin_mode_t
     * }
     */
    public static final OfShort __darwin_mode_t = unistd_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_off_t
     * }
     */
    public static final OfLong __darwin_off_t = unistd_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_pid_t
     * }
     */
    public static final OfInt __darwin_pid_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_sigset_t
     * }
     */
    public static final OfInt __darwin_sigset_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_suseconds_t
     * }
     */
    public static final OfInt __darwin_suseconds_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_uid_t
     * }
     */
    public static final OfInt __darwin_uid_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_useconds_t
     * }
     */
    public static final OfInt __darwin_useconds_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_pthread_key_t
     * }
     */
    public static final OfLong __darwin_pthread_key_t = unistd_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _opaque_pthread_t {
     *     long __sig;
     *     struct __darwin_pthread_handler_rec *__cleanup_stack;
     *     char __opaque[8176];
     * } *__darwin_pthread_t
     * }
     */
    public static final AddressLayout __darwin_pthread_t = unistd_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_nl_item
     * }
     */
    public static final OfInt __darwin_nl_item = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wctrans_t
     * }
     */
    public static final OfInt __darwin_wctrans_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_wctype_t
     * }
     */
    public static final OfInt __darwin_wctype_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t size_t
     * }
     */
    public static final OfLong size_t = unistd_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = unistd_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = unistd_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = unistd_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_int8_t
     * }
     */
    public static final OfByte u_int8_t = unistd_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_int16_t
     * }
     */
    public static final OfShort u_int16_t = unistd_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int32_t
     * }
     */
    public static final OfInt u_int32_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long u_int64_t
     * }
     */
    public static final OfLong u_int64_t = unistd_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t register_t
     * }
     */
    public static final OfLong register_t = unistd_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_intptr_t intptr_t
     * }
     */
    public static final OfLong intptr_t = unistd_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = unistd_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_addr_t
     * }
     */
    public static final OfLong user_addr_t = unistd_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_size_t
     * }
     */
    public static final OfLong user_size_t = unistd_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_ssize_t
     * }
     */
    public static final OfLong user_ssize_t = unistd_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_long_t
     * }
     */
    public static final OfLong user_long_t = unistd_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_ulong_t
     * }
     */
    public static final OfLong user_ulong_t = unistd_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_time_t
     * }
     */
    public static final OfLong user_time_t = unistd_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_off_t
     * }
     */
    public static final OfLong user_off_t = unistd_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t syscall_arg_t
     * }
     */
    public static final OfLong syscall_arg_t = unistd_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = unistd_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = unistd_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = unistd_h.C_INT;

    private static class getattrlistbulk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_LONG,
            unistd_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getattrlistbulk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getattrlistbulk(int, void *, void *, size_t, uint64_t)
     * }
     */
    public static FunctionDescriptor getattrlistbulk$descriptor() {
        return getattrlistbulk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getattrlistbulk(int, void *, void *, size_t, uint64_t)
     * }
     */
    public static MethodHandle getattrlistbulk$handle() {
        return getattrlistbulk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getattrlistbulk(int, void *, void *, size_t, uint64_t)
     * }
     */
    public static MemorySegment getattrlistbulk$address() {
        return getattrlistbulk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getattrlistbulk(int, void *, void *, size_t, uint64_t)
     * }
     */
    public static int getattrlistbulk(int x0, MemorySegment x1, MemorySegment x2, long x3, long x4) {
        var mh$ = getattrlistbulk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getattrlistbulk", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getattrlistat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_LONG,
            unistd_h.C_LONG
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getattrlistat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getattrlistat(int, const char *, void *, void *, size_t, unsigned long)
     * }
     */
    public static FunctionDescriptor getattrlistat$descriptor() {
        return getattrlistat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getattrlistat(int, const char *, void *, void *, size_t, unsigned long)
     * }
     */
    public static MethodHandle getattrlistat$handle() {
        return getattrlistat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getattrlistat(int, const char *, void *, void *, size_t, unsigned long)
     * }
     */
    public static MemorySegment getattrlistat$address() {
        return getattrlistat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getattrlistat(int, const char *, void *, void *, size_t, unsigned long)
     * }
     */
    public static int getattrlistat(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, long x5) {
        var mh$ = getattrlistat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getattrlistat", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setattrlistat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_LONG,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("setattrlistat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setattrlistat(int, const char *, void *, void *, size_t, uint32_t)
     * }
     */
    public static FunctionDescriptor setattrlistat$descriptor() {
        return setattrlistat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setattrlistat(int, const char *, void *, void *, size_t, uint32_t)
     * }
     */
    public static MethodHandle setattrlistat$handle() {
        return setattrlistat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setattrlistat(int, const char *, void *, void *, size_t, uint32_t)
     * }
     */
    public static MemorySegment setattrlistat$address() {
        return setattrlistat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setattrlistat(int, const char *, void *, void *, size_t, uint32_t)
     * }
     */
    public static int setattrlistat(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = setattrlistat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setattrlistat", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freadlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_LONG,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_LONG
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("freadlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t freadlink(int, char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor freadlink$descriptor() {
        return freadlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t freadlink(int, char *restrict, size_t)
     * }
     */
    public static MethodHandle freadlink$handle() {
        return freadlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t freadlink(int, char *restrict, size_t)
     * }
     */
    public static MemorySegment freadlink$address() {
        return freadlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t freadlink(int, char *restrict, size_t)
     * }
     */
    public static long freadlink(int x0, MemorySegment x1, long x2) {
        var mh$ = freadlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freadlink", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_uid_t uid_t
     * }
     */
    public static final OfInt uid_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_gid_t gid_t
     * }
     */
    public static final OfInt gid_t = unistd_h.C_INT;

    private static class faccessat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("faccessat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int faccessat(int, const char *, int, int)
     * }
     */
    public static FunctionDescriptor faccessat$descriptor() {
        return faccessat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int faccessat(int, const char *, int, int)
     * }
     */
    public static MethodHandle faccessat$handle() {
        return faccessat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int faccessat(int, const char *, int, int)
     * }
     */
    public static MemorySegment faccessat$address() {
        return faccessat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int faccessat(int, const char *, int, int)
     * }
     */
    public static int faccessat(int x0, MemorySegment x1, int x2, int x3) {
        var mh$ = faccessat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("faccessat", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchownat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("fchownat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchownat(int, const char *, uid_t, gid_t, int)
     * }
     */
    public static FunctionDescriptor fchownat$descriptor() {
        return fchownat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchownat(int, const char *, uid_t, gid_t, int)
     * }
     */
    public static MethodHandle fchownat$handle() {
        return fchownat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchownat(int, const char *, uid_t, gid_t, int)
     * }
     */
    public static MemorySegment fchownat$address() {
        return fchownat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchownat(int, const char *, uid_t, gid_t, int)
     * }
     */
    public static int fchownat(int x0, MemorySegment x1, int x2, int x3, int x4) {
        var mh$ = fchownat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchownat", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class linkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("linkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int linkat(int, const char *, int, const char *, int)
     * }
     */
    public static FunctionDescriptor linkat$descriptor() {
        return linkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int linkat(int, const char *, int, const char *, int)
     * }
     */
    public static MethodHandle linkat$handle() {
        return linkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int linkat(int, const char *, int, const char *, int)
     * }
     */
    public static MemorySegment linkat$address() {
        return linkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int linkat(int, const char *, int, const char *, int)
     * }
     */
    public static int linkat(int x0, MemorySegment x1, int x2, MemorySegment x3, int x4) {
        var mh$ = linkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("linkat", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readlinkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_LONG,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_LONG
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("readlinkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t readlinkat(int, const char *, char *, size_t)
     * }
     */
    public static FunctionDescriptor readlinkat$descriptor() {
        return readlinkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t readlinkat(int, const char *, char *, size_t)
     * }
     */
    public static MethodHandle readlinkat$handle() {
        return readlinkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t readlinkat(int, const char *, char *, size_t)
     * }
     */
    public static MemorySegment readlinkat$address() {
        return readlinkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t readlinkat(int, const char *, char *, size_t)
     * }
     */
    public static long readlinkat(int x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = readlinkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readlinkat", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class symlinkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("symlinkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int symlinkat(const char *, int, const char *)
     * }
     */
    public static FunctionDescriptor symlinkat$descriptor() {
        return symlinkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int symlinkat(const char *, int, const char *)
     * }
     */
    public static MethodHandle symlinkat$handle() {
        return symlinkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int symlinkat(const char *, int, const char *)
     * }
     */
    public static MemorySegment symlinkat$address() {
        return symlinkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int symlinkat(const char *, int, const char *)
     * }
     */
    public static int symlinkat(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = symlinkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("symlinkat", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlinkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("unlinkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlinkat(int, const char *, int)
     * }
     */
    public static FunctionDescriptor unlinkat$descriptor() {
        return unlinkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlinkat(int, const char *, int)
     * }
     */
    public static MethodHandle unlinkat$handle() {
        return unlinkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unlinkat(int, const char *, int)
     * }
     */
    public static MemorySegment unlinkat$address() {
        return unlinkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unlinkat(int, const char *, int)
     * }
     */
    public static int unlinkat(int x0, MemorySegment x1, int x2) {
        var mh$ = unlinkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlinkat", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_off_t off_t
     * }
     */
    public static final OfLong off_t = unistd_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_pid_t pid_t
     * }
     */
    public static final OfInt pid_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_useconds_t useconds_t
     * }
     */
    public static final OfInt useconds_t = unistd_h.C_INT;

    private static class _exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _exit(int)
     * }
     */
    public static FunctionDescriptor _exit$descriptor() {
        return _exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _exit(int)
     * }
     */
    public static MethodHandle _exit$handle() {
        return _exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _exit(int)
     * }
     */
    public static MemorySegment _exit$address() {
        return _exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _exit(int)
     * }
     */
    public static void _exit(int x0) {
        var mh$ = _exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class access {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("access");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int access(const char *, int)
     * }
     */
    public static FunctionDescriptor access$descriptor() {
        return access.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int access(const char *, int)
     * }
     */
    public static MethodHandle access$handle() {
        return access.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int access(const char *, int)
     * }
     */
    public static MemorySegment access$address() {
        return access.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int access(const char *, int)
     * }
     */
    public static int access(MemorySegment x0, int x1) {
        var mh$ = access.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("access", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alarm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("alarm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int alarm(unsigned int)
     * }
     */
    public static FunctionDescriptor alarm$descriptor() {
        return alarm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int alarm(unsigned int)
     * }
     */
    public static MethodHandle alarm$handle() {
        return alarm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int alarm(unsigned int)
     * }
     */
    public static MemorySegment alarm$address() {
        return alarm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int alarm(unsigned int)
     * }
     */
    public static int alarm(int x0) {
        var mh$ = alarm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alarm", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("chdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chdir(const char *)
     * }
     */
    public static FunctionDescriptor chdir$descriptor() {
        return chdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chdir(const char *)
     * }
     */
    public static MethodHandle chdir$handle() {
        return chdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chdir(const char *)
     * }
     */
    public static MemorySegment chdir$address() {
        return chdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chdir(const char *)
     * }
     */
    public static int chdir(MemorySegment x0) {
        var mh$ = chdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chdir", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("chown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chown(const char *, uid_t, gid_t)
     * }
     */
    public static FunctionDescriptor chown$descriptor() {
        return chown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chown(const char *, uid_t, gid_t)
     * }
     */
    public static MethodHandle chown$handle() {
        return chown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chown(const char *, uid_t, gid_t)
     * }
     */
    public static MemorySegment chown$address() {
        return chown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chown(const char *, uid_t, gid_t)
     * }
     */
    public static int chown(MemorySegment x0, int x1, int x2) {
        var mh$ = chown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chown", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int close(int)
     * }
     */
    public static FunctionDescriptor close$descriptor() {
        return close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int close(int)
     * }
     */
    public static MethodHandle close$handle() {
        return close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int close(int)
     * }
     */
    public static MemorySegment close$address() {
        return close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int close(int)
     * }
     */
    public static int close(int x0) {
        var mh$ = close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("close", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dup(int)
     * }
     */
    public static FunctionDescriptor dup$descriptor() {
        return dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dup(int)
     * }
     */
    public static MethodHandle dup$handle() {
        return dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dup(int)
     * }
     */
    public static MemorySegment dup$address() {
        return dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dup(int)
     * }
     */
    public static int dup(int x0) {
        var mh$ = dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dup", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dup2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("dup2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dup2(int, int)
     * }
     */
    public static FunctionDescriptor dup2$descriptor() {
        return dup2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dup2(int, int)
     * }
     */
    public static MethodHandle dup2$handle() {
        return dup2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dup2(int, int)
     * }
     */
    public static MemorySegment dup2$address() {
        return dup2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dup2(int, int)
     * }
     */
    public static int dup2(int x0, int x1) {
        var mh$ = dup2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dup2", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int execl(const char *__path, const char *__arg0, ...)
     * }
     */
    public static class execl {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                unistd_h.C_INT,
                unistd_h.C_POINTER,
                unistd_h.C_POINTER
            );
        private static final MemorySegment ADDR = unistd_h.findOrThrow("execl");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private execl(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int execl(const char *__path, const char *__arg0, ...)
         * }
         */
        public static execl makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new execl(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __path, MemorySegment __arg0, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("execl", __path, __arg0, x2);
                }
                return (int) spreader.invokeExact(__path, __arg0, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int execle(const char *__path, const char *__arg0, ...)
     * }
     */
    public static class execle {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                unistd_h.C_INT,
                unistd_h.C_POINTER,
                unistd_h.C_POINTER
            );
        private static final MemorySegment ADDR = unistd_h.findOrThrow("execle");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private execle(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int execle(const char *__path, const char *__arg0, ...)
         * }
         */
        public static execle makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new execle(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __path, MemorySegment __arg0, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("execle", __path, __arg0, x2);
                }
                return (int) spreader.invokeExact(__path, __arg0, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int execlp(const char *__file, const char *__arg0, ...)
     * }
     */
    public static class execlp {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                unistd_h.C_INT,
                unistd_h.C_POINTER,
                unistd_h.C_POINTER
            );
        private static final MemorySegment ADDR = unistd_h.findOrThrow("execlp");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private execlp(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int execlp(const char *__file, const char *__arg0, ...)
         * }
         */
        public static execlp makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new execlp(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __file, MemorySegment __arg0, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("execlp", __file, __arg0, x2);
                }
                return (int) spreader.invokeExact(__file, __arg0, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class execv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("execv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int execv(const char *__path, char *const *__argv)
     * }
     */
    public static FunctionDescriptor execv$descriptor() {
        return execv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int execv(const char *__path, char *const *__argv)
     * }
     */
    public static MethodHandle execv$handle() {
        return execv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int execv(const char *__path, char *const *__argv)
     * }
     */
    public static MemorySegment execv$address() {
        return execv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int execv(const char *__path, char *const *__argv)
     * }
     */
    public static int execv(MemorySegment __path, MemorySegment __argv) {
        var mh$ = execv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("execv", __path, __argv);
            }
            return (int)mh$.invokeExact(__path, __argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class execve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("execve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int execve(const char *__file, char *const *__argv, char *const *__envp)
     * }
     */
    public static FunctionDescriptor execve$descriptor() {
        return execve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int execve(const char *__file, char *const *__argv, char *const *__envp)
     * }
     */
    public static MethodHandle execve$handle() {
        return execve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int execve(const char *__file, char *const *__argv, char *const *__envp)
     * }
     */
    public static MemorySegment execve$address() {
        return execve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int execve(const char *__file, char *const *__argv, char *const *__envp)
     * }
     */
    public static int execve(MemorySegment __file, MemorySegment __argv, MemorySegment __envp) {
        var mh$ = execve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("execve", __file, __argv, __envp);
            }
            return (int)mh$.invokeExact(__file, __argv, __envp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class execvp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("execvp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int execvp(const char *__file, char *const *__argv)
     * }
     */
    public static FunctionDescriptor execvp$descriptor() {
        return execvp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int execvp(const char *__file, char *const *__argv)
     * }
     */
    public static MethodHandle execvp$handle() {
        return execvp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int execvp(const char *__file, char *const *__argv)
     * }
     */
    public static MemorySegment execvp$address() {
        return execvp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int execvp(const char *__file, char *const *__argv)
     * }
     */
    public static int execvp(MemorySegment __file, MemorySegment __argv) {
        var mh$ = execvp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("execvp", __file, __argv);
            }
            return (int)mh$.invokeExact(__file, __argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT    );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("fork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t fork()
     * }
     */
    public static FunctionDescriptor fork$descriptor() {
        return fork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t fork()
     * }
     */
    public static MethodHandle fork$handle() {
        return fork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t fork()
     * }
     */
    public static MemorySegment fork$address() {
        return fork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t fork()
     * }
     */
    public static int fork() {
        var mh$ = fork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fork");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fpathconf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_LONG,
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("fpathconf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long fpathconf(int, int)
     * }
     */
    public static FunctionDescriptor fpathconf$descriptor() {
        return fpathconf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long fpathconf(int, int)
     * }
     */
    public static MethodHandle fpathconf$handle() {
        return fpathconf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long fpathconf(int, int)
     * }
     */
    public static MemorySegment fpathconf$address() {
        return fpathconf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long fpathconf(int, int)
     * }
     */
    public static long fpathconf(int x0, int x1) {
        var mh$ = fpathconf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fpathconf", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getcwd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_LONG
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getcwd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getcwd(char *, size_t)
     * }
     */
    public static FunctionDescriptor getcwd$descriptor() {
        return getcwd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getcwd(char *, size_t)
     * }
     */
    public static MethodHandle getcwd$handle() {
        return getcwd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getcwd(char *, size_t)
     * }
     */
    public static MemorySegment getcwd$address() {
        return getcwd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getcwd(char *, size_t)
     * }
     */
    public static MemorySegment getcwd(MemorySegment x0, long x1) {
        var mh$ = getcwd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getcwd", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getegid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT    );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getegid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * gid_t getegid()
     * }
     */
    public static FunctionDescriptor getegid$descriptor() {
        return getegid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * gid_t getegid()
     * }
     */
    public static MethodHandle getegid$handle() {
        return getegid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * gid_t getegid()
     * }
     */
    public static MemorySegment getegid$address() {
        return getegid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * gid_t getegid()
     * }
     */
    public static int getegid() {
        var mh$ = getegid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getegid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class geteuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT    );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("geteuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uid_t geteuid()
     * }
     */
    public static FunctionDescriptor geteuid$descriptor() {
        return geteuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uid_t geteuid()
     * }
     */
    public static MethodHandle geteuid$handle() {
        return geteuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uid_t geteuid()
     * }
     */
    public static MemorySegment geteuid$address() {
        return geteuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uid_t geteuid()
     * }
     */
    public static int geteuid() {
        var mh$ = geteuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("geteuid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT    );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * gid_t getgid()
     * }
     */
    public static FunctionDescriptor getgid$descriptor() {
        return getgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * gid_t getgid()
     * }
     */
    public static MethodHandle getgid$handle() {
        return getgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * gid_t getgid()
     * }
     */
    public static MemorySegment getgid$address() {
        return getgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * gid_t getgid()
     * }
     */
    public static int getgid() {
        var mh$ = getgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getgroups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getgroups(int, gid_t [])
     * }
     */
    public static FunctionDescriptor getgroups$descriptor() {
        return getgroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getgroups(int, gid_t [])
     * }
     */
    public static MethodHandle getgroups$handle() {
        return getgroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getgroups(int, gid_t [])
     * }
     */
    public static MemorySegment getgroups$address() {
        return getgroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getgroups(int, gid_t [])
     * }
     */
    public static int getgroups(int x0, MemorySegment x1) {
        var mh$ = getgroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgroups", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getlogin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_POINTER    );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getlogin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getlogin()
     * }
     */
    public static FunctionDescriptor getlogin$descriptor() {
        return getlogin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getlogin()
     * }
     */
    public static MethodHandle getlogin$handle() {
        return getlogin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getlogin()
     * }
     */
    public static MemorySegment getlogin$address() {
        return getlogin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getlogin()
     * }
     */
    public static MemorySegment getlogin() {
        var mh$ = getlogin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getlogin");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT    );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getpgrp()
     * }
     */
    public static FunctionDescriptor getpgrp$descriptor() {
        return getpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getpgrp()
     * }
     */
    public static MethodHandle getpgrp$handle() {
        return getpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getpgrp()
     * }
     */
    public static MemorySegment getpgrp$address() {
        return getpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getpgrp()
     * }
     */
    public static int getpgrp() {
        var mh$ = getpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpgrp");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT    );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getpid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getpid()
     * }
     */
    public static FunctionDescriptor getpid$descriptor() {
        return getpid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getpid()
     * }
     */
    public static MethodHandle getpid$handle() {
        return getpid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getpid()
     * }
     */
    public static MemorySegment getpid$address() {
        return getpid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getpid()
     * }
     */
    public static int getpid() {
        var mh$ = getpid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getppid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT    );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getppid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getppid()
     * }
     */
    public static FunctionDescriptor getppid$descriptor() {
        return getppid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getppid()
     * }
     */
    public static MethodHandle getppid$handle() {
        return getppid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getppid()
     * }
     */
    public static MemorySegment getppid$address() {
        return getppid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getppid()
     * }
     */
    public static int getppid() {
        var mh$ = getppid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getppid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT    );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uid_t getuid()
     * }
     */
    public static FunctionDescriptor getuid$descriptor() {
        return getuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uid_t getuid()
     * }
     */
    public static MethodHandle getuid$handle() {
        return getuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uid_t getuid()
     * }
     */
    public static MemorySegment getuid$address() {
        return getuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uid_t getuid()
     * }
     */
    public static int getuid() {
        var mh$ = getuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getuid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isatty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("isatty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isatty(int)
     * }
     */
    public static FunctionDescriptor isatty$descriptor() {
        return isatty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isatty(int)
     * }
     */
    public static MethodHandle isatty$handle() {
        return isatty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isatty(int)
     * }
     */
    public static MemorySegment isatty$address() {
        return isatty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isatty(int)
     * }
     */
    public static int isatty(int x0) {
        var mh$ = isatty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isatty", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int link(const char *, const char *)
     * }
     */
    public static FunctionDescriptor link$descriptor() {
        return link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int link(const char *, const char *)
     * }
     */
    public static MethodHandle link$handle() {
        return link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int link(const char *, const char *)
     * }
     */
    public static MemorySegment link$address() {
        return link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int link(const char *, const char *)
     * }
     */
    public static int link(MemorySegment x0, MemorySegment x1) {
        var mh$ = link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("link", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_LONG_LONG,
            unistd_h.C_INT,
            unistd_h.C_LONG_LONG,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("lseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * off_t lseek(int, off_t, int)
     * }
     */
    public static FunctionDescriptor lseek$descriptor() {
        return lseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * off_t lseek(int, off_t, int)
     * }
     */
    public static MethodHandle lseek$handle() {
        return lseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * off_t lseek(int, off_t, int)
     * }
     */
    public static MemorySegment lseek$address() {
        return lseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * off_t lseek(int, off_t, int)
     * }
     */
    public static long lseek(int x0, long x1, int x2) {
        var mh$ = lseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lseek", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pathconf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_LONG,
            unistd_h.C_POINTER,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("pathconf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long pathconf(const char *, int)
     * }
     */
    public static FunctionDescriptor pathconf$descriptor() {
        return pathconf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long pathconf(const char *, int)
     * }
     */
    public static MethodHandle pathconf$handle() {
        return pathconf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long pathconf(const char *, int)
     * }
     */
    public static MemorySegment pathconf$address() {
        return pathconf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long pathconf(const char *, int)
     * }
     */
    public static long pathconf(MemorySegment x0, int x1) {
        var mh$ = pathconf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pathconf", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT    );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("pause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pause()
     * }
     */
    public static FunctionDescriptor pause$descriptor() {
        return pause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pause()
     * }
     */
    public static MethodHandle pause$handle() {
        return pause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pause()
     * }
     */
    public static MemorySegment pause$address() {
        return pause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pause()
     * }
     */
    public static int pause() {
        var mh$ = pause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pause");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("pipe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pipe(int [2])
     * }
     */
    public static FunctionDescriptor pipe$descriptor() {
        return pipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pipe(int [2])
     * }
     */
    public static MethodHandle pipe$handle() {
        return pipe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pipe(int [2])
     * }
     */
    public static MemorySegment pipe$address() {
        return pipe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pipe(int [2])
     * }
     */
    public static int pipe(MemorySegment x0) {
        var mh$ = pipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pipe", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_LONG,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_LONG
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t read(int, void *, size_t)
     * }
     */
    public static FunctionDescriptor read$descriptor() {
        return read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t read(int, void *, size_t)
     * }
     */
    public static MethodHandle read$handle() {
        return read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t read(int, void *, size_t)
     * }
     */
    public static MemorySegment read$address() {
        return read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t read(int, void *, size_t)
     * }
     */
    public static long read(int x0, MemorySegment x1, long x2) {
        var mh$ = read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("read", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("rmdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rmdir(const char *)
     * }
     */
    public static FunctionDescriptor rmdir$descriptor() {
        return rmdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rmdir(const char *)
     * }
     */
    public static MethodHandle rmdir$handle() {
        return rmdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rmdir(const char *)
     * }
     */
    public static MemorySegment rmdir$address() {
        return rmdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rmdir(const char *)
     * }
     */
    public static int rmdir(MemorySegment x0) {
        var mh$ = rmdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmdir", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("setgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setgid(gid_t)
     * }
     */
    public static FunctionDescriptor setgid$descriptor() {
        return setgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setgid(gid_t)
     * }
     */
    public static MethodHandle setgid$handle() {
        return setgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setgid(gid_t)
     * }
     */
    public static MemorySegment setgid$address() {
        return setgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setgid(gid_t)
     * }
     */
    public static int setgid(int x0) {
        var mh$ = setgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setgid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("setpgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setpgid(pid_t, pid_t)
     * }
     */
    public static FunctionDescriptor setpgid$descriptor() {
        return setpgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setpgid(pid_t, pid_t)
     * }
     */
    public static MethodHandle setpgid$handle() {
        return setpgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setpgid(pid_t, pid_t)
     * }
     */
    public static MemorySegment setpgid$address() {
        return setpgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setpgid(pid_t, pid_t)
     * }
     */
    public static int setpgid(int x0, int x1) {
        var mh$ = setpgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpgid", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT    );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("setsid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t setsid()
     * }
     */
    public static FunctionDescriptor setsid$descriptor() {
        return setsid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t setsid()
     * }
     */
    public static MethodHandle setsid$handle() {
        return setsid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t setsid()
     * }
     */
    public static MemorySegment setsid$address() {
        return setsid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t setsid()
     * }
     */
    public static int setsid() {
        var mh$ = setsid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("setuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setuid(uid_t)
     * }
     */
    public static FunctionDescriptor setuid$descriptor() {
        return setuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setuid(uid_t)
     * }
     */
    public static MethodHandle setuid$handle() {
        return setuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setuid(uid_t)
     * }
     */
    public static MemorySegment setuid$address() {
        return setuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setuid(uid_t)
     * }
     */
    public static int setuid(int x0) {
        var mh$ = setuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setuid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("sleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int sleep(unsigned int)
     * }
     */
    public static FunctionDescriptor sleep$descriptor() {
        return sleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int sleep(unsigned int)
     * }
     */
    public static MethodHandle sleep$handle() {
        return sleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int sleep(unsigned int)
     * }
     */
    public static MemorySegment sleep$address() {
        return sleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int sleep(unsigned int)
     * }
     */
    public static int sleep(int x0) {
        var mh$ = sleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sleep", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sysconf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_LONG,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("sysconf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long sysconf(int)
     * }
     */
    public static FunctionDescriptor sysconf$descriptor() {
        return sysconf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long sysconf(int)
     * }
     */
    public static MethodHandle sysconf$handle() {
        return sysconf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long sysconf(int)
     * }
     */
    public static MemorySegment sysconf$address() {
        return sysconf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long sysconf(int)
     * }
     */
    public static long sysconf(int x0) {
        var mh$ = sysconf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sysconf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tcgetpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("tcgetpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t tcgetpgrp(int)
     * }
     */
    public static FunctionDescriptor tcgetpgrp$descriptor() {
        return tcgetpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t tcgetpgrp(int)
     * }
     */
    public static MethodHandle tcgetpgrp$handle() {
        return tcgetpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t tcgetpgrp(int)
     * }
     */
    public static MemorySegment tcgetpgrp$address() {
        return tcgetpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t tcgetpgrp(int)
     * }
     */
    public static int tcgetpgrp(int x0) {
        var mh$ = tcgetpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tcgetpgrp", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tcsetpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("tcsetpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int tcsetpgrp(int, pid_t)
     * }
     */
    public static FunctionDescriptor tcsetpgrp$descriptor() {
        return tcsetpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int tcsetpgrp(int, pid_t)
     * }
     */
    public static MethodHandle tcsetpgrp$handle() {
        return tcsetpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int tcsetpgrp(int, pid_t)
     * }
     */
    public static MemorySegment tcsetpgrp$address() {
        return tcsetpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int tcsetpgrp(int, pid_t)
     * }
     */
    public static int tcsetpgrp(int x0, int x1) {
        var mh$ = tcsetpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tcsetpgrp", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ttyname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_POINTER,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("ttyname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ttyname(int)
     * }
     */
    public static FunctionDescriptor ttyname$descriptor() {
        return ttyname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ttyname(int)
     * }
     */
    public static MethodHandle ttyname$handle() {
        return ttyname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ttyname(int)
     * }
     */
    public static MemorySegment ttyname$address() {
        return ttyname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ttyname(int)
     * }
     */
    public static MemorySegment ttyname(int x0) {
        var mh$ = ttyname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ttyname", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ttyname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_LONG
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("ttyname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ttyname_r(int, char *, size_t)
     * }
     */
    public static FunctionDescriptor ttyname_r$descriptor() {
        return ttyname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ttyname_r(int, char *, size_t)
     * }
     */
    public static MethodHandle ttyname_r$handle() {
        return ttyname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ttyname_r(int, char *, size_t)
     * }
     */
    public static MemorySegment ttyname_r$address() {
        return ttyname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ttyname_r(int, char *, size_t)
     * }
     */
    public static int ttyname_r(int x0, MemorySegment x1, long x2) {
        var mh$ = ttyname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ttyname_r", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("unlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlink(const char *)
     * }
     */
    public static FunctionDescriptor unlink$descriptor() {
        return unlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlink(const char *)
     * }
     */
    public static MethodHandle unlink$handle() {
        return unlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unlink(const char *)
     * }
     */
    public static MemorySegment unlink$address() {
        return unlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unlink(const char *)
     * }
     */
    public static int unlink(MemorySegment x0) {
        var mh$ = unlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlink", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_LONG,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_LONG
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t write(int __fd, const void *__buf, size_t __nbyte)
     * }
     */
    public static FunctionDescriptor write$descriptor() {
        return write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t write(int __fd, const void *__buf, size_t __nbyte)
     * }
     */
    public static MethodHandle write$handle() {
        return write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t write(int __fd, const void *__buf, size_t __nbyte)
     * }
     */
    public static MemorySegment write$address() {
        return write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t write(int __fd, const void *__buf, size_t __nbyte)
     * }
     */
    public static long write(int __fd, MemorySegment __buf, long __nbyte) {
        var mh$ = write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("write", __fd, __buf, __nbyte);
            }
            return (long)mh$.invokeExact(__fd, __buf, __nbyte);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class confstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_LONG,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_LONG
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("confstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t confstr(int, char *, size_t)
     * }
     */
    public static FunctionDescriptor confstr$descriptor() {
        return confstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t confstr(int, char *, size_t)
     * }
     */
    public static MethodHandle confstr$handle() {
        return confstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t confstr(int, char *, size_t)
     * }
     */
    public static MemorySegment confstr$address() {
        return confstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t confstr(int, char *, size_t)
     * }
     */
    public static long confstr(int x0, MemorySegment x1, long x2) {
        var mh$ = confstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("confstr", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getopt(int, char *const [], const char *)
     * }
     */
    public static FunctionDescriptor getopt$descriptor() {
        return getopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getopt(int, char *const [], const char *)
     * }
     */
    public static MethodHandle getopt$handle() {
        return getopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getopt(int, char *const [], const char *)
     * }
     */
    public static MemorySegment getopt$address() {
        return getopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getopt(int, char *const [], const char *)
     * }
     */
    public static int getopt(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getopt", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class optarg$constants {
        public static final AddressLayout LAYOUT = unistd_h.C_POINTER;
        public static final MemorySegment SEGMENT = unistd_h.findOrThrow("optarg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static AddressLayout optarg$layout() {
        return optarg$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static MemorySegment optarg$segment() {
        return optarg$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static MemorySegment optarg() {
        return optarg$constants.SEGMENT.get(optarg$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static void optarg(MemorySegment varValue) {
        optarg$constants.SEGMENT.set(optarg$constants.LAYOUT, 0L, varValue);
    }

    private static class optind$constants {
        public static final OfInt LAYOUT = unistd_h.C_INT;
        public static final MemorySegment SEGMENT = unistd_h.findOrThrow("optind").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static OfInt optind$layout() {
        return optind$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static MemorySegment optind$segment() {
        return optind$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static int optind() {
        return optind$constants.SEGMENT.get(optind$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static void optind(int varValue) {
        optind$constants.SEGMENT.set(optind$constants.LAYOUT, 0L, varValue);
    }

    private static class opterr$constants {
        public static final OfInt LAYOUT = unistd_h.C_INT;
        public static final MemorySegment SEGMENT = unistd_h.findOrThrow("opterr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static OfInt opterr$layout() {
        return opterr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static MemorySegment opterr$segment() {
        return opterr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static int opterr() {
        return opterr$constants.SEGMENT.get(opterr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static void opterr(int varValue) {
        opterr$constants.SEGMENT.set(opterr$constants.LAYOUT, 0L, varValue);
    }

    private static class optopt$constants {
        public static final OfInt LAYOUT = unistd_h.C_INT;
        public static final MemorySegment SEGMENT = unistd_h.findOrThrow("optopt").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static OfInt optopt$layout() {
        return optopt$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static MemorySegment optopt$segment() {
        return optopt$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static int optopt() {
        return optopt$constants.SEGMENT.get(optopt$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static void optopt(int varValue) {
        optopt$constants.SEGMENT.set(optopt$constants.LAYOUT, 0L, varValue);
    }

    private static class ctermid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("ctermid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static FunctionDescriptor ctermid$descriptor() {
        return ctermid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MethodHandle ctermid$handle() {
        return ctermid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MemorySegment ctermid$address() {
        return ctermid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MemorySegment ctermid(MemorySegment x0) {
        var mh$ = ctermid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class brk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("brk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *brk(const void *)
     * }
     */
    public static FunctionDescriptor brk$descriptor() {
        return brk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *brk(const void *)
     * }
     */
    public static MethodHandle brk$handle() {
        return brk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *brk(const void *)
     * }
     */
    public static MemorySegment brk$address() {
        return brk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *brk(const void *)
     * }
     */
    public static MemorySegment brk(MemorySegment x0) {
        var mh$ = brk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("brk", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chroot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("chroot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chroot(const char *)
     * }
     */
    public static FunctionDescriptor chroot$descriptor() {
        return chroot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chroot(const char *)
     * }
     */
    public static MethodHandle chroot$handle() {
        return chroot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chroot(const char *)
     * }
     */
    public static MemorySegment chroot$address() {
        return chroot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chroot(const char *)
     * }
     */
    public static int chroot(MemorySegment x0) {
        var mh$ = chroot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chroot", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class crypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("crypt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *crypt(const char *, const char *)
     * }
     */
    public static FunctionDescriptor crypt$descriptor() {
        return crypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *crypt(const char *, const char *)
     * }
     */
    public static MethodHandle crypt$handle() {
        return crypt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *crypt(const char *, const char *)
     * }
     */
    public static MemorySegment crypt$address() {
        return crypt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *crypt(const char *, const char *)
     * }
     */
    public static MemorySegment crypt(MemorySegment x0, MemorySegment x1) {
        var mh$ = crypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("crypt", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class encrypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            unistd_h.C_POINTER,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("encrypt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void encrypt(char *, int)
     * }
     */
    public static FunctionDescriptor encrypt$descriptor() {
        return encrypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void encrypt(char *, int)
     * }
     */
    public static MethodHandle encrypt$handle() {
        return encrypt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void encrypt(char *, int)
     * }
     */
    public static MemorySegment encrypt$address() {
        return encrypt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void encrypt(char *, int)
     * }
     */
    public static void encrypt(MemorySegment x0, int x1) {
        var mh$ = encrypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("encrypt", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("fchdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchdir(int)
     * }
     */
    public static FunctionDescriptor fchdir$descriptor() {
        return fchdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchdir(int)
     * }
     */
    public static MethodHandle fchdir$handle() {
        return fchdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchdir(int)
     * }
     */
    public static MemorySegment fchdir$address() {
        return fchdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchdir(int)
     * }
     */
    public static int fchdir(int x0) {
        var mh$ = fchdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchdir", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_LONG    );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("gethostid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long gethostid()
     * }
     */
    public static FunctionDescriptor gethostid$descriptor() {
        return gethostid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long gethostid()
     * }
     */
    public static MethodHandle gethostid$handle() {
        return gethostid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long gethostid()
     * }
     */
    public static MemorySegment gethostid$address() {
        return gethostid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long gethostid()
     * }
     */
    public static long gethostid() {
        var mh$ = gethostid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostid");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getpgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getpgid(pid_t)
     * }
     */
    public static FunctionDescriptor getpgid$descriptor() {
        return getpgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getpgid(pid_t)
     * }
     */
    public static MethodHandle getpgid$handle() {
        return getpgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getpgid(pid_t)
     * }
     */
    public static MemorySegment getpgid$address() {
        return getpgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getpgid(pid_t)
     * }
     */
    public static int getpgid(int x0) {
        var mh$ = getpgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpgid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getsid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getsid(pid_t)
     * }
     */
    public static FunctionDescriptor getsid$descriptor() {
        return getsid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getsid(pid_t)
     * }
     */
    public static MethodHandle getsid$handle() {
        return getsid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getsid(pid_t)
     * }
     */
    public static MemorySegment getsid$address() {
        return getsid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getsid(pid_t)
     * }
     */
    public static int getsid(int x0) {
        var mh$ = getsid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdtablesize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT    );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getdtablesize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getdtablesize()
     * }
     */
    public static FunctionDescriptor getdtablesize$descriptor() {
        return getdtablesize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getdtablesize()
     * }
     */
    public static MethodHandle getdtablesize$handle() {
        return getdtablesize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getdtablesize()
     * }
     */
    public static MemorySegment getdtablesize$address() {
        return getdtablesize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getdtablesize()
     * }
     */
    public static int getdtablesize() {
        var mh$ = getdtablesize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdtablesize");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpagesize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT    );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getpagesize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpagesize()
     * }
     */
    public static FunctionDescriptor getpagesize$descriptor() {
        return getpagesize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpagesize()
     * }
     */
    public static MethodHandle getpagesize$handle() {
        return getpagesize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpagesize()
     * }
     */
    public static MemorySegment getpagesize$address() {
        return getpagesize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpagesize()
     * }
     */
    public static int getpagesize() {
        var mh$ = getpagesize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpagesize");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getpass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getpass(const char *)
     * }
     */
    public static FunctionDescriptor getpass$descriptor() {
        return getpass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getpass(const char *)
     * }
     */
    public static MethodHandle getpass$handle() {
        return getpass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getpass(const char *)
     * }
     */
    public static MemorySegment getpass$address() {
        return getpass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getpass(const char *)
     * }
     */
    public static MemorySegment getpass(MemorySegment x0) {
        var mh$ = getpass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpass", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getwd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getwd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getwd(char *)
     * }
     */
    public static FunctionDescriptor getwd$descriptor() {
        return getwd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getwd(char *)
     * }
     */
    public static MethodHandle getwd$handle() {
        return getwd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getwd(char *)
     * }
     */
    public static MemorySegment getwd$address() {
        return getwd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getwd(char *)
     * }
     */
    public static MemorySegment getwd(MemorySegment x0) {
        var mh$ = getwd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwd", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lchown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("lchown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lchown(const char *, uid_t, gid_t)
     * }
     */
    public static FunctionDescriptor lchown$descriptor() {
        return lchown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lchown(const char *, uid_t, gid_t)
     * }
     */
    public static MethodHandle lchown$handle() {
        return lchown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lchown(const char *, uid_t, gid_t)
     * }
     */
    public static MemorySegment lchown$address() {
        return lchown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lchown(const char *, uid_t, gid_t)
     * }
     */
    public static int lchown(MemorySegment x0, int x1, int x2) {
        var mh$ = lchown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lchown", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lockf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("lockf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lockf(int, int, off_t)
     * }
     */
    public static FunctionDescriptor lockf$descriptor() {
        return lockf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lockf(int, int, off_t)
     * }
     */
    public static MethodHandle lockf$handle() {
        return lockf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lockf(int, int, off_t)
     * }
     */
    public static MemorySegment lockf$address() {
        return lockf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lockf(int, int, off_t)
     * }
     */
    public static int lockf(int x0, int x1, long x2) {
        var mh$ = lockf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lockf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("nice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int nice(int)
     * }
     */
    public static FunctionDescriptor nice$descriptor() {
        return nice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int nice(int)
     * }
     */
    public static MethodHandle nice$handle() {
        return nice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int nice(int)
     * }
     */
    public static MemorySegment nice$address() {
        return nice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int nice(int)
     * }
     */
    public static int nice(int x0) {
        var mh$ = nice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nice", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_LONG,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_LONG,
            unistd_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("pread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static FunctionDescriptor pread$descriptor() {
        return pread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static MethodHandle pread$handle() {
        return pread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static MemorySegment pread$address() {
        return pread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static long pread(int __fd, MemorySegment __buf, long __nbyte, long __offset) {
        var mh$ = pread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pread", __fd, __buf, __nbyte, __offset);
            }
            return (long)mh$.invokeExact(__fd, __buf, __nbyte, __offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_LONG,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_LONG,
            unistd_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("pwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static FunctionDescriptor pwrite$descriptor() {
        return pwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static MethodHandle pwrite$handle() {
        return pwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static MemorySegment pwrite$address() {
        return pwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static long pwrite(int __fd, MemorySegment __buf, long __nbyte, long __offset) {
        var mh$ = pwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pwrite", __fd, __buf, __nbyte, __offset);
            }
            return (long)mh$.invokeExact(__fd, __buf, __nbyte, __offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_POINTER,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("sbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *sbrk(int)
     * }
     */
    public static FunctionDescriptor sbrk$descriptor() {
        return sbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *sbrk(int)
     * }
     */
    public static MethodHandle sbrk$handle() {
        return sbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *sbrk(int)
     * }
     */
    public static MemorySegment sbrk$address() {
        return sbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *sbrk(int)
     * }
     */
    public static MemorySegment sbrk(int x0) {
        var mh$ = sbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sbrk", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT    );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("setpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t setpgrp()
     * }
     */
    public static FunctionDescriptor setpgrp$descriptor() {
        return setpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t setpgrp()
     * }
     */
    public static MethodHandle setpgrp$handle() {
        return setpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t setpgrp()
     * }
     */
    public static MemorySegment setpgrp$address() {
        return setpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t setpgrp()
     * }
     */
    public static int setpgrp() {
        var mh$ = setpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpgrp");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setregid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("setregid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setregid(gid_t, gid_t)
     * }
     */
    public static FunctionDescriptor setregid$descriptor() {
        return setregid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setregid(gid_t, gid_t)
     * }
     */
    public static MethodHandle setregid$handle() {
        return setregid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setregid(gid_t, gid_t)
     * }
     */
    public static MemorySegment setregid$address() {
        return setregid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setregid(gid_t, gid_t)
     * }
     */
    public static int setregid(int x0, int x1) {
        var mh$ = setregid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setregid", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setreuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("setreuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setreuid(uid_t, uid_t)
     * }
     */
    public static FunctionDescriptor setreuid$descriptor() {
        return setreuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setreuid(uid_t, uid_t)
     * }
     */
    public static MethodHandle setreuid$handle() {
        return setreuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setreuid(uid_t, uid_t)
     * }
     */
    public static MemorySegment setreuid$address() {
        return setreuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setreuid(uid_t, uid_t)
     * }
     */
    public static int setreuid(int x0, int x1) {
        var mh$ = setreuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setreuid", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_LONG
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("swab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static FunctionDescriptor swab$descriptor() {
        return swab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static MethodHandle swab$handle() {
        return swab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static MemorySegment swab$address() {
        return swab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static void swab(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = swab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swab", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("sync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sync()
     * }
     */
    public static FunctionDescriptor sync$descriptor() {
        return sync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sync()
     * }
     */
    public static MethodHandle sync$handle() {
        return sync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sync()
     * }
     */
    public static MemorySegment sync$address() {
        return sync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sync()
     * }
     */
    public static void sync() {
        var mh$ = sync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sync");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class truncate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("truncate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int truncate(const char *, off_t)
     * }
     */
    public static FunctionDescriptor truncate$descriptor() {
        return truncate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int truncate(const char *, off_t)
     * }
     */
    public static MethodHandle truncate$handle() {
        return truncate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int truncate(const char *, off_t)
     * }
     */
    public static MemorySegment truncate$address() {
        return truncate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int truncate(const char *, off_t)
     * }
     */
    public static int truncate(MemorySegment x0, long x1) {
        var mh$ = truncate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("truncate", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ualarm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("ualarm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * useconds_t ualarm(useconds_t, useconds_t)
     * }
     */
    public static FunctionDescriptor ualarm$descriptor() {
        return ualarm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * useconds_t ualarm(useconds_t, useconds_t)
     * }
     */
    public static MethodHandle ualarm$handle() {
        return ualarm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * useconds_t ualarm(useconds_t, useconds_t)
     * }
     */
    public static MemorySegment ualarm$address() {
        return ualarm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * useconds_t ualarm(useconds_t, useconds_t)
     * }
     */
    public static int ualarm(int x0, int x1) {
        var mh$ = ualarm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ualarm", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class usleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("usleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int usleep(useconds_t)
     * }
     */
    public static FunctionDescriptor usleep$descriptor() {
        return usleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int usleep(useconds_t)
     * }
     */
    public static MethodHandle usleep$handle() {
        return usleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int usleep(useconds_t)
     * }
     */
    public static MemorySegment usleep$address() {
        return usleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int usleep(useconds_t)
     * }
     */
    public static int usleep(int x0) {
        var mh$ = usleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("usleep", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vfork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT    );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("vfork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vfork()
     * }
     */
    public static FunctionDescriptor vfork$descriptor() {
        return vfork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vfork()
     * }
     */
    public static MethodHandle vfork$handle() {
        return vfork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vfork()
     * }
     */
    public static MemorySegment vfork$address() {
        return vfork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vfork()
     * }
     */
    public static int vfork() {
        var mh$ = vfork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfork");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("fsync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsync(int)
     * }
     */
    public static FunctionDescriptor fsync$descriptor() {
        return fsync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsync(int)
     * }
     */
    public static MethodHandle fsync$handle() {
        return fsync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsync(int)
     * }
     */
    public static MemorySegment fsync$address() {
        return fsync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsync(int)
     * }
     */
    public static int fsync(int x0) {
        var mh$ = fsync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsync", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftruncate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("ftruncate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ftruncate(int, off_t)
     * }
     */
    public static FunctionDescriptor ftruncate$descriptor() {
        return ftruncate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ftruncate(int, off_t)
     * }
     */
    public static MethodHandle ftruncate$handle() {
        return ftruncate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ftruncate(int, off_t)
     * }
     */
    public static MemorySegment ftruncate$address() {
        return ftruncate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ftruncate(int, off_t)
     * }
     */
    public static int ftruncate(int x0, long x1) {
        var mh$ = ftruncate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftruncate", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getlogin_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_LONG
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getlogin_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getlogin_r(char *, size_t)
     * }
     */
    public static FunctionDescriptor getlogin_r$descriptor() {
        return getlogin_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getlogin_r(char *, size_t)
     * }
     */
    public static MethodHandle getlogin_r$handle() {
        return getlogin_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getlogin_r(char *, size_t)
     * }
     */
    public static MemorySegment getlogin_r$address() {
        return getlogin_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getlogin_r(char *, size_t)
     * }
     */
    public static int getlogin_r(MemorySegment x0, long x1) {
        var mh$ = getlogin_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getlogin_r", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("fchown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchown(int, uid_t, gid_t)
     * }
     */
    public static FunctionDescriptor fchown$descriptor() {
        return fchown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchown(int, uid_t, gid_t)
     * }
     */
    public static MethodHandle fchown$handle() {
        return fchown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchown(int, uid_t, gid_t)
     * }
     */
    public static MemorySegment fchown$address() {
        return fchown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchown(int, uid_t, gid_t)
     * }
     */
    public static int fchown(int x0, int x1, int x2) {
        var mh$ = fchown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchown", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_LONG
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("gethostname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gethostname(char *, size_t)
     * }
     */
    public static FunctionDescriptor gethostname$descriptor() {
        return gethostname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gethostname(char *, size_t)
     * }
     */
    public static MethodHandle gethostname$handle() {
        return gethostname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gethostname(char *, size_t)
     * }
     */
    public static MemorySegment gethostname$address() {
        return gethostname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gethostname(char *, size_t)
     * }
     */
    public static int gethostname(MemorySegment x0, long x1) {
        var mh$ = gethostname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostname", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_LONG,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_LONG
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("readlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t readlink(const char *restrict, char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor readlink$descriptor() {
        return readlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t readlink(const char *restrict, char *restrict, size_t)
     * }
     */
    public static MethodHandle readlink$handle() {
        return readlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t readlink(const char *restrict, char *restrict, size_t)
     * }
     */
    public static MemorySegment readlink$address() {
        return readlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t readlink(const char *restrict, char *restrict, size_t)
     * }
     */
    public static long readlink(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = readlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readlink", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setegid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("setegid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setegid(gid_t)
     * }
     */
    public static FunctionDescriptor setegid$descriptor() {
        return setegid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setegid(gid_t)
     * }
     */
    public static MethodHandle setegid$handle() {
        return setegid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setegid(gid_t)
     * }
     */
    public static MemorySegment setegid$address() {
        return setegid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setegid(gid_t)
     * }
     */
    public static int setegid(int x0) {
        var mh$ = setegid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setegid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seteuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("seteuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int seteuid(uid_t)
     * }
     */
    public static FunctionDescriptor seteuid$descriptor() {
        return seteuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int seteuid(uid_t)
     * }
     */
    public static MethodHandle seteuid$handle() {
        return seteuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int seteuid(uid_t)
     * }
     */
    public static MemorySegment seteuid$address() {
        return seteuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int seteuid(uid_t)
     * }
     */
    public static int seteuid(int x0) {
        var mh$ = seteuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seteuid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class symlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("symlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int symlink(const char *, const char *)
     * }
     */
    public static FunctionDescriptor symlink$descriptor() {
        return symlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int symlink(const char *, const char *)
     * }
     */
    public static MethodHandle symlink$handle() {
        return symlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int symlink(const char *, const char *)
     * }
     */
    public static MemorySegment symlink$address() {
        return symlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int symlink(const char *, const char *)
     * }
     */
    public static int symlink(MemorySegment x0, MemorySegment x1) {
        var mh$ = symlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("symlink", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __darwin_check_fd_set_overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("__darwin_check_fd_set_overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static FunctionDescriptor __darwin_check_fd_set_overflow$descriptor() {
        return __darwin_check_fd_set_overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static MethodHandle __darwin_check_fd_set_overflow$handle() {
        return __darwin_check_fd_set_overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static MemorySegment __darwin_check_fd_set_overflow$address() {
        return __darwin_check_fd_set_overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static int __darwin_check_fd_set_overflow(int x0, MemorySegment x1, int x2) {
        var mh$ = __darwin_check_fd_set_overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__darwin_check_fd_set_overflow", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_time_t time_t
     * }
     */
    public static final OfLong time_t = unistd_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_suseconds_t suseconds_t
     * }
     */
    public static final OfInt suseconds_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_sigset_t sigset_t
     * }
     */
    public static final OfInt sigset_t = unistd_h.C_INT;

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("pselect$1050");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static MemorySegment pselect$address() {
        return pselect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static int pselect(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("select$1050");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static int select(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_dev_t dev_t
     * }
     */
    public static final OfInt dev_t = unistd_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mode_t mode_t
     * }
     */
    public static final OfShort mode_t = unistd_h.C_SHORT;

    private static class _Exit$ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit$.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit$.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit$.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static void _Exit(int x0) {
        var mh$ = _Exit$.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class accessx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_LONG,
            unistd_h.C_POINTER,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("accessx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t)
     * }
     */
    public static FunctionDescriptor accessx_np$descriptor() {
        return accessx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t)
     * }
     */
    public static MethodHandle accessx_np$handle() {
        return accessx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t)
     * }
     */
    public static MemorySegment accessx_np$address() {
        return accessx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t)
     * }
     */
    public static int accessx_np(MemorySegment x0, long x1, MemorySegment x2, int x3) {
        var mh$ = accessx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("accessx_np", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("acct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int acct(const char *)
     * }
     */
    public static FunctionDescriptor acct$descriptor() {
        return acct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int acct(const char *)
     * }
     */
    public static MethodHandle acct$handle() {
        return acct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int acct(const char *)
     * }
     */
    public static MemorySegment acct$address() {
        return acct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int acct(const char *)
     * }
     */
    public static int acct(MemorySegment x0) {
        var mh$ = acct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acct", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class add_profil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_LONG,
            unistd_h.C_LONG,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("add_profil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int add_profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static FunctionDescriptor add_profil$descriptor() {
        return add_profil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int add_profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static MethodHandle add_profil$handle() {
        return add_profil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int add_profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static MemorySegment add_profil$address() {
        return add_profil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int add_profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static int add_profil(MemorySegment x0, long x1, long x2, int x3) {
        var mh$ = add_profil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("add_profil", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class endusershell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("endusershell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void endusershell()
     * }
     */
    public static FunctionDescriptor endusershell$descriptor() {
        return endusershell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void endusershell()
     * }
     */
    public static MethodHandle endusershell$handle() {
        return endusershell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void endusershell()
     * }
     */
    public static MemorySegment endusershell$address() {
        return endusershell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void endusershell()
     * }
     */
    public static void endusershell() {
        var mh$ = endusershell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("endusershell");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class execvP$ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("execvP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int execvP(const char *__file, const char *__searchpath, char *const *__argv)
     * }
     */
    public static FunctionDescriptor execvP$descriptor() {
        return execvP$.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int execvP(const char *__file, const char *__searchpath, char *const *__argv)
     * }
     */
    public static MethodHandle execvP$handle() {
        return execvP$.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int execvP(const char *__file, const char *__searchpath, char *const *__argv)
     * }
     */
    public static MemorySegment execvP$address() {
        return execvP$.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int execvP(const char *__file, const char *__searchpath, char *const *__argv)
     * }
     */
    public static int execvP(MemorySegment __file, MemorySegment __searchpath, MemorySegment __argv) {
        var mh$ = execvP$.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("execvP", __file, __searchpath, __argv);
            }
            return (int)mh$.invokeExact(__file, __searchpath, __argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflagstostr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_POINTER,
            unistd_h.C_LONG
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("fflagstostr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fflagstostr(unsigned long)
     * }
     */
    public static FunctionDescriptor fflagstostr$descriptor() {
        return fflagstostr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fflagstostr(unsigned long)
     * }
     */
    public static MethodHandle fflagstostr$handle() {
        return fflagstostr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fflagstostr(unsigned long)
     * }
     */
    public static MemorySegment fflagstostr$address() {
        return fflagstostr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fflagstostr(unsigned long)
     * }
     */
    public static MemorySegment fflagstostr(long x0) {
        var mh$ = fflagstostr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflagstostr", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdomainname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getdomainname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getdomainname(char *, int)
     * }
     */
    public static FunctionDescriptor getdomainname$descriptor() {
        return getdomainname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getdomainname(char *, int)
     * }
     */
    public static MethodHandle getdomainname$handle() {
        return getdomainname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getdomainname(char *, int)
     * }
     */
    public static MemorySegment getdomainname$address() {
        return getdomainname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getdomainname(char *, int)
     * }
     */
    public static int getdomainname(MemorySegment x0, int x1) {
        var mh$ = getdomainname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdomainname", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgrouplist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getgrouplist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getgrouplist(const char *, int, int *, int *)
     * }
     */
    public static FunctionDescriptor getgrouplist$descriptor() {
        return getgrouplist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getgrouplist(const char *, int, int *, int *)
     * }
     */
    public static MethodHandle getgrouplist$handle() {
        return getgrouplist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getgrouplist(const char *, int, int *, int *)
     * }
     */
    public static MemorySegment getgrouplist$address() {
        return getgrouplist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getgrouplist(const char *, int, int *, int *)
     * }
     */
    public static int getgrouplist(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = getgrouplist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgrouplist", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostuuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("gethostuuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gethostuuid(uuid_t, const struct timespec *)
     * }
     */
    public static FunctionDescriptor gethostuuid$descriptor() {
        return gethostuuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gethostuuid(uuid_t, const struct timespec *)
     * }
     */
    public static MethodHandle gethostuuid$handle() {
        return gethostuuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gethostuuid(uuid_t, const struct timespec *)
     * }
     */
    public static MemorySegment gethostuuid$address() {
        return gethostuuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gethostuuid(uuid_t, const struct timespec *)
     * }
     */
    public static int gethostuuid(MemorySegment x0, MemorySegment x1) {
        var mh$ = gethostuuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostuuid", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_SHORT,
            unistd_h.C_POINTER,
            unistd_h.C_SHORT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mode_t getmode(const void *, mode_t)
     * }
     */
    public static FunctionDescriptor getmode$descriptor() {
        return getmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mode_t getmode(const void *, mode_t)
     * }
     */
    public static MethodHandle getmode$handle() {
        return getmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mode_t getmode(const void *, mode_t)
     * }
     */
    public static MemorySegment getmode$address() {
        return getmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mode_t getmode(const void *, mode_t)
     * }
     */
    public static short getmode(MemorySegment x0, short x1) {
        var mh$ = getmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getmode", x0, x1);
            }
            return (short)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpeereid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getpeereid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpeereid(int, uid_t *, gid_t *)
     * }
     */
    public static FunctionDescriptor getpeereid$descriptor() {
        return getpeereid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpeereid(int, uid_t *, gid_t *)
     * }
     */
    public static MethodHandle getpeereid$handle() {
        return getpeereid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpeereid(int, uid_t *, gid_t *)
     * }
     */
    public static MemorySegment getpeereid$address() {
        return getpeereid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpeereid(int, uid_t *, gid_t *)
     * }
     */
    public static int getpeereid(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getpeereid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpeereid", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsgroups_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getsgroups_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsgroups_np(int *, uuid_t)
     * }
     */
    public static FunctionDescriptor getsgroups_np$descriptor() {
        return getsgroups_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsgroups_np(int *, uuid_t)
     * }
     */
    public static MethodHandle getsgroups_np$handle() {
        return getsgroups_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsgroups_np(int *, uuid_t)
     * }
     */
    public static MemorySegment getsgroups_np$address() {
        return getsgroups_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsgroups_np(int *, uuid_t)
     * }
     */
    public static int getsgroups_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = getsgroups_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsgroups_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getusershell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_POINTER    );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getusershell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getusershell()
     * }
     */
    public static FunctionDescriptor getusershell$descriptor() {
        return getusershell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getusershell()
     * }
     */
    public static MethodHandle getusershell$handle() {
        return getusershell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getusershell()
     * }
     */
    public static MemorySegment getusershell$address() {
        return getusershell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getusershell()
     * }
     */
    public static MemorySegment getusershell() {
        var mh$ = getusershell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getusershell");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getwgroups_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getwgroups_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getwgroups_np(int *, uuid_t)
     * }
     */
    public static FunctionDescriptor getwgroups_np$descriptor() {
        return getwgroups_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getwgroups_np(int *, uuid_t)
     * }
     */
    public static MethodHandle getwgroups_np$handle() {
        return getwgroups_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getwgroups_np(int *, uuid_t)
     * }
     */
    public static MemorySegment getwgroups_np$address() {
        return getwgroups_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getwgroups_np(int *, uuid_t)
     * }
     */
    public static int getwgroups_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = getwgroups_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwgroups_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initgroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("initgroups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int initgroups(const char *, int)
     * }
     */
    public static FunctionDescriptor initgroups$descriptor() {
        return initgroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int initgroups(const char *, int)
     * }
     */
    public static MethodHandle initgroups$handle() {
        return initgroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int initgroups(const char *, int)
     * }
     */
    public static MemorySegment initgroups$address() {
        return initgroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int initgroups(const char *, int)
     * }
     */
    public static int initgroups(MemorySegment x0, int x1) {
        var mh$ = initgroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initgroups", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class issetugid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT    );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("issetugid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int issetugid()
     * }
     */
    public static FunctionDescriptor issetugid$descriptor() {
        return issetugid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int issetugid()
     * }
     */
    public static MethodHandle issetugid$handle() {
        return issetugid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int issetugid()
     * }
     */
    public static MemorySegment issetugid$address() {
        return issetugid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int issetugid()
     * }
     */
    public static int issetugid() {
        var mh$ = issetugid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("issetugid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdtemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("mkdtemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *mkdtemp(char *)
     * }
     */
    public static FunctionDescriptor mkdtemp$descriptor() {
        return mkdtemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *mkdtemp(char *)
     * }
     */
    public static MethodHandle mkdtemp$handle() {
        return mkdtemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *mkdtemp(char *)
     * }
     */
    public static MemorySegment mkdtemp$address() {
        return mkdtemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *mkdtemp(char *)
     * }
     */
    public static MemorySegment mkdtemp(MemorySegment x0) {
        var mh$ = mkdtemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdtemp", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mknod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_SHORT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("mknod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static FunctionDescriptor mknod$descriptor() {
        return mknod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static MethodHandle mknod$handle() {
        return mknod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static MemorySegment mknod$address() {
        return mknod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static int mknod(MemorySegment x0, short x1, int x2) {
        var mh$ = mknod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mknod", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkpath_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_SHORT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("mkpath_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkpath_np(const char *path, mode_t omode)
     * }
     */
    public static FunctionDescriptor mkpath_np$descriptor() {
        return mkpath_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkpath_np(const char *path, mode_t omode)
     * }
     */
    public static MethodHandle mkpath_np$handle() {
        return mkpath_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkpath_np(const char *path, mode_t omode)
     * }
     */
    public static MemorySegment mkpath_np$address() {
        return mkpath_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkpath_np(const char *path, mode_t omode)
     * }
     */
    public static int mkpath_np(MemorySegment path, short omode) {
        var mh$ = mkpath_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkpath_np", path, omode);
            }
            return (int)mh$.invokeExact(path, omode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkpathat_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_SHORT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("mkpathat_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkpathat_np(int dfd, const char *path, mode_t omode)
     * }
     */
    public static FunctionDescriptor mkpathat_np$descriptor() {
        return mkpathat_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkpathat_np(int dfd, const char *path, mode_t omode)
     * }
     */
    public static MethodHandle mkpathat_np$handle() {
        return mkpathat_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkpathat_np(int dfd, const char *path, mode_t omode)
     * }
     */
    public static MemorySegment mkpathat_np$address() {
        return mkpathat_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkpathat_np(int dfd, const char *path, mode_t omode)
     * }
     */
    public static int mkpathat_np(int dfd, MemorySegment path, short omode) {
        var mh$ = mkpathat_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkpathat_np", dfd, path, omode);
            }
            return (int)mh$.invokeExact(dfd, path, omode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("mkstemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MemorySegment mkstemp$address() {
        return mkstemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static int mkstemp(MemorySegment x0) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("mkstemps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstemps(char *, int)
     * }
     */
    public static FunctionDescriptor mkstemps$descriptor() {
        return mkstemps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstemps(char *, int)
     * }
     */
    public static MethodHandle mkstemps$handle() {
        return mkstemps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstemps(char *, int)
     * }
     */
    public static MemorySegment mkstemps$address() {
        return mkstemps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstemps(char *, int)
     * }
     */
    public static int mkstemps(MemorySegment x0, int x1) {
        var mh$ = mkstemps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemps", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp$address() {
        return mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp(MemorySegment x0) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkostemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("mkostemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkostemp(char *path, int oflags)
     * }
     */
    public static FunctionDescriptor mkostemp$descriptor() {
        return mkostemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkostemp(char *path, int oflags)
     * }
     */
    public static MethodHandle mkostemp$handle() {
        return mkostemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkostemp(char *path, int oflags)
     * }
     */
    public static MemorySegment mkostemp$address() {
        return mkostemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkostemp(char *path, int oflags)
     * }
     */
    public static int mkostemp(MemorySegment path, int oflags) {
        var mh$ = mkostemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkostemp", path, oflags);
            }
            return (int)mh$.invokeExact(path, oflags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkostemps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("mkostemps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkostemps(char *path, int slen, int oflags)
     * }
     */
    public static FunctionDescriptor mkostemps$descriptor() {
        return mkostemps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkostemps(char *path, int slen, int oflags)
     * }
     */
    public static MethodHandle mkostemps$handle() {
        return mkostemps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkostemps(char *path, int slen, int oflags)
     * }
     */
    public static MemorySegment mkostemps$address() {
        return mkostemps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkostemps(char *path, int slen, int oflags)
     * }
     */
    public static int mkostemps(MemorySegment path, int slen, int oflags) {
        var mh$ = mkostemps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkostemps", path, slen, oflags);
            }
            return (int)mh$.invokeExact(path, slen, oflags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp_dprotected_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("mkstemp_dprotected_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
     * }
     */
    public static FunctionDescriptor mkstemp_dprotected_np$descriptor() {
        return mkstemp_dprotected_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
     * }
     */
    public static MethodHandle mkstemp_dprotected_np$handle() {
        return mkstemp_dprotected_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
     * }
     */
    public static MemorySegment mkstemp_dprotected_np$address() {
        return mkstemp_dprotected_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
     * }
     */
    public static int mkstemp_dprotected_np(MemorySegment path, int dpclass, int dpflags) {
        var mh$ = mkstemp_dprotected_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp_dprotected_np", path, dpclass, dpflags);
            }
            return (int)mh$.invokeExact(path, dpclass, dpflags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdtempat_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_POINTER,
            unistd_h.C_INT,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("mkdtempat_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *mkdtempat_np(int dfd, char *path)
     * }
     */
    public static FunctionDescriptor mkdtempat_np$descriptor() {
        return mkdtempat_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *mkdtempat_np(int dfd, char *path)
     * }
     */
    public static MethodHandle mkdtempat_np$handle() {
        return mkdtempat_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *mkdtempat_np(int dfd, char *path)
     * }
     */
    public static MemorySegment mkdtempat_np$address() {
        return mkdtempat_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *mkdtempat_np(int dfd, char *path)
     * }
     */
    public static MemorySegment mkdtempat_np(int dfd, MemorySegment path) {
        var mh$ = mkdtempat_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdtempat_np", dfd, path);
            }
            return (MemorySegment)mh$.invokeExact(dfd, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstempsat_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("mkstempsat_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstempsat_np(int dfd, char *path, int slen)
     * }
     */
    public static FunctionDescriptor mkstempsat_np$descriptor() {
        return mkstempsat_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstempsat_np(int dfd, char *path, int slen)
     * }
     */
    public static MethodHandle mkstempsat_np$handle() {
        return mkstempsat_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstempsat_np(int dfd, char *path, int slen)
     * }
     */
    public static MemorySegment mkstempsat_np$address() {
        return mkstempsat_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstempsat_np(int dfd, char *path, int slen)
     * }
     */
    public static int mkstempsat_np(int dfd, MemorySegment path, int slen) {
        var mh$ = mkstempsat_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstempsat_np", dfd, path, slen);
            }
            return (int)mh$.invokeExact(dfd, path, slen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkostempsat_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("mkostempsat_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkostempsat_np(int dfd, char *path, int slen, int oflags)
     * }
     */
    public static FunctionDescriptor mkostempsat_np$descriptor() {
        return mkostempsat_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkostempsat_np(int dfd, char *path, int slen, int oflags)
     * }
     */
    public static MethodHandle mkostempsat_np$handle() {
        return mkostempsat_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkostempsat_np(int dfd, char *path, int slen, int oflags)
     * }
     */
    public static MemorySegment mkostempsat_np$address() {
        return mkostempsat_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkostempsat_np(int dfd, char *path, int slen, int oflags)
     * }
     */
    public static int mkostempsat_np(int dfd, MemorySegment path, int slen, int oflags) {
        var mh$ = mkostempsat_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkostempsat_np", dfd, path, slen, oflags);
            }
            return (int)mh$.invokeExact(dfd, path, slen, oflags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nfssvc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("nfssvc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int nfssvc(int, void *)
     * }
     */
    public static FunctionDescriptor nfssvc$descriptor() {
        return nfssvc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int nfssvc(int, void *)
     * }
     */
    public static MethodHandle nfssvc$handle() {
        return nfssvc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int nfssvc(int, void *)
     * }
     */
    public static MemorySegment nfssvc$address() {
        return nfssvc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int nfssvc(int, void *)
     * }
     */
    public static int nfssvc(int x0, MemorySegment x1) {
        var mh$ = nfssvc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nfssvc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class profil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_LONG,
            unistd_h.C_LONG,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("profil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static FunctionDescriptor profil$descriptor() {
        return profil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static MethodHandle profil$handle() {
        return profil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static MemorySegment profil$address() {
        return profil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static int profil(MemorySegment x0, long x1, long x2, int x3) {
        var mh$ = profil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("profil", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setugid_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("pthread_setugid_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_setugid_np(uid_t, gid_t)
     * }
     */
    public static FunctionDescriptor pthread_setugid_np$descriptor() {
        return pthread_setugid_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_setugid_np(uid_t, gid_t)
     * }
     */
    public static MethodHandle pthread_setugid_np$handle() {
        return pthread_setugid_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_setugid_np(uid_t, gid_t)
     * }
     */
    public static MemorySegment pthread_setugid_np$address() {
        return pthread_setugid_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_setugid_np(uid_t, gid_t)
     * }
     */
    public static int pthread_setugid_np(int x0, int x1) {
        var mh$ = pthread_setugid_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setugid_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_getugid_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("pthread_getugid_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_getugid_np(uid_t *, gid_t *)
     * }
     */
    public static FunctionDescriptor pthread_getugid_np$descriptor() {
        return pthread_getugid_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_getugid_np(uid_t *, gid_t *)
     * }
     */
    public static MethodHandle pthread_getugid_np$handle() {
        return pthread_getugid_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_getugid_np(uid_t *, gid_t *)
     * }
     */
    public static MemorySegment pthread_getugid_np$address() {
        return pthread_getugid_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_getugid_np(uid_t *, gid_t *)
     * }
     */
    public static int pthread_getugid_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_getugid_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_getugid_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reboot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("reboot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int reboot(int)
     * }
     */
    public static FunctionDescriptor reboot$descriptor() {
        return reboot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int reboot(int)
     * }
     */
    public static MethodHandle reboot$handle() {
        return reboot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int reboot(int)
     * }
     */
    public static MemorySegment reboot$address() {
        return reboot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int reboot(int)
     * }
     */
    public static int reboot(int x0) {
        var mh$ = reboot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reboot", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class revoke {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("revoke");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int revoke(const char *)
     * }
     */
    public static FunctionDescriptor revoke$descriptor() {
        return revoke.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int revoke(const char *)
     * }
     */
    public static MethodHandle revoke$handle() {
        return revoke.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int revoke(const char *)
     * }
     */
    public static MemorySegment revoke$address() {
        return revoke.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int revoke(const char *)
     * }
     */
    public static int revoke(MemorySegment x0) {
        var mh$ = revoke.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("revoke", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcmd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("rcmd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rcmd(char **, int, const char *, const char *, const char *, int *)
     * }
     */
    public static FunctionDescriptor rcmd$descriptor() {
        return rcmd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rcmd(char **, int, const char *, const char *, const char *, int *)
     * }
     */
    public static MethodHandle rcmd$handle() {
        return rcmd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rcmd(char **, int, const char *, const char *, const char *, int *)
     * }
     */
    public static MemorySegment rcmd$address() {
        return rcmd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rcmd(char **, int, const char *, const char *, const char *, int *)
     * }
     */
    public static int rcmd(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = rcmd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcmd", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcmd_af {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("rcmd_af");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rcmd_af(char **, int, const char *, const char *, const char *, int *, int)
     * }
     */
    public static FunctionDescriptor rcmd_af$descriptor() {
        return rcmd_af.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rcmd_af(char **, int, const char *, const char *, const char *, int *, int)
     * }
     */
    public static MethodHandle rcmd_af$handle() {
        return rcmd_af.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rcmd_af(char **, int, const char *, const char *, const char *, int *, int)
     * }
     */
    public static MemorySegment rcmd_af$address() {
        return rcmd_af.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rcmd_af(char **, int, const char *, const char *, const char *, int *, int)
     * }
     */
    public static int rcmd_af(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, int x6) {
        var mh$ = rcmd_af.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcmd_af", x0, x1, x2, x3, x4, x5, x6);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rresvport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("rresvport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rresvport(int *)
     * }
     */
    public static FunctionDescriptor rresvport$descriptor() {
        return rresvport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rresvport(int *)
     * }
     */
    public static MethodHandle rresvport$handle() {
        return rresvport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rresvport(int *)
     * }
     */
    public static MemorySegment rresvport$address() {
        return rresvport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rresvport(int *)
     * }
     */
    public static int rresvport(MemorySegment x0) {
        var mh$ = rresvport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rresvport", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rresvport_af {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("rresvport_af");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rresvport_af(int *, int)
     * }
     */
    public static FunctionDescriptor rresvport_af$descriptor() {
        return rresvport_af.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rresvport_af(int *, int)
     * }
     */
    public static MethodHandle rresvport_af$handle() {
        return rresvport_af.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rresvport_af(int *, int)
     * }
     */
    public static MemorySegment rresvport_af$address() {
        return rresvport_af.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rresvport_af(int *, int)
     * }
     */
    public static int rresvport_af(MemorySegment x0, int x1) {
        var mh$ = rresvport_af.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rresvport_af", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iruserok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_LONG,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("iruserok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iruserok(unsigned long, int, const char *, const char *)
     * }
     */
    public static FunctionDescriptor iruserok$descriptor() {
        return iruserok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iruserok(unsigned long, int, const char *, const char *)
     * }
     */
    public static MethodHandle iruserok$handle() {
        return iruserok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iruserok(unsigned long, int, const char *, const char *)
     * }
     */
    public static MemorySegment iruserok$address() {
        return iruserok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iruserok(unsigned long, int, const char *, const char *)
     * }
     */
    public static int iruserok(long x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = iruserok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iruserok", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iruserok_sa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("iruserok_sa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iruserok_sa(const void *, int, int, const char *, const char *)
     * }
     */
    public static FunctionDescriptor iruserok_sa$descriptor() {
        return iruserok_sa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iruserok_sa(const void *, int, int, const char *, const char *)
     * }
     */
    public static MethodHandle iruserok_sa$handle() {
        return iruserok_sa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iruserok_sa(const void *, int, int, const char *, const char *)
     * }
     */
    public static MemorySegment iruserok_sa$address() {
        return iruserok_sa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iruserok_sa(const void *, int, int, const char *, const char *)
     * }
     */
    public static int iruserok_sa(MemorySegment x0, int x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = iruserok_sa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iruserok_sa", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ruserok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("ruserok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ruserok(const char *, int, const char *, const char *)
     * }
     */
    public static FunctionDescriptor ruserok$descriptor() {
        return ruserok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ruserok(const char *, int, const char *, const char *)
     * }
     */
    public static MethodHandle ruserok$handle() {
        return ruserok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ruserok(const char *, int, const char *, const char *)
     * }
     */
    public static MemorySegment ruserok$address() {
        return ruserok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ruserok(const char *, int, const char *, const char *)
     * }
     */
    public static int ruserok(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ruserok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ruserok", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setdomainname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("setdomainname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setdomainname(const char *, int)
     * }
     */
    public static FunctionDescriptor setdomainname$descriptor() {
        return setdomainname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setdomainname(const char *, int)
     * }
     */
    public static MethodHandle setdomainname$handle() {
        return setdomainname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setdomainname(const char *, int)
     * }
     */
    public static MemorySegment setdomainname$address() {
        return setdomainname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setdomainname(const char *, int)
     * }
     */
    public static int setdomainname(MemorySegment x0, int x1) {
        var mh$ = setdomainname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setdomainname", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setgroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("setgroups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setgroups(int, const gid_t *)
     * }
     */
    public static FunctionDescriptor setgroups$descriptor() {
        return setgroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setgroups(int, const gid_t *)
     * }
     */
    public static MethodHandle setgroups$handle() {
        return setgroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setgroups(int, const gid_t *)
     * }
     */
    public static MemorySegment setgroups$address() {
        return setgroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setgroups(int, const gid_t *)
     * }
     */
    public static int setgroups(int x0, MemorySegment x1) {
        var mh$ = setgroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setgroups", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sethostid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            unistd_h.C_LONG
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("sethostid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sethostid(long)
     * }
     */
    public static FunctionDescriptor sethostid$descriptor() {
        return sethostid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sethostid(long)
     * }
     */
    public static MethodHandle sethostid$handle() {
        return sethostid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sethostid(long)
     * }
     */
    public static MemorySegment sethostid$address() {
        return sethostid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sethostid(long)
     * }
     */
    public static void sethostid(long x0) {
        var mh$ = sethostid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sethostid", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sethostname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("sethostname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sethostname(const char *, int)
     * }
     */
    public static FunctionDescriptor sethostname$descriptor() {
        return sethostname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sethostname(const char *, int)
     * }
     */
    public static MethodHandle sethostname$handle() {
        return sethostname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sethostname(const char *, int)
     * }
     */
    public static MemorySegment sethostname$address() {
        return sethostname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sethostname(const char *, int)
     * }
     */
    public static int sethostname(MemorySegment x0, int x1) {
        var mh$ = sethostname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sethostname", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setkey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("setkey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static FunctionDescriptor setkey$descriptor() {
        return setkey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static MethodHandle setkey$handle() {
        return setkey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static MemorySegment setkey$address() {
        return setkey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static void setkey(MemorySegment x0) {
        var mh$ = setkey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setkey", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlogin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("setlogin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setlogin(const char *)
     * }
     */
    public static FunctionDescriptor setlogin$descriptor() {
        return setlogin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setlogin(const char *)
     * }
     */
    public static MethodHandle setlogin$handle() {
        return setlogin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setlogin(const char *)
     * }
     */
    public static MemorySegment setlogin$address() {
        return setlogin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setlogin(const char *)
     * }
     */
    public static int setlogin(MemorySegment x0) {
        var mh$ = setlogin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlogin", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("setmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *setmode(const char *)
     * }
     */
    public static FunctionDescriptor setmode$descriptor() {
        return setmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *setmode(const char *)
     * }
     */
    public static MethodHandle setmode$handle() {
        return setmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *setmode(const char *)
     * }
     */
    public static MemorySegment setmode$address() {
        return setmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *setmode(const char *)
     * }
     */
    public static MemorySegment setmode(MemorySegment x0) {
        var mh$ = setmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setmode", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setrgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("setrgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setrgid(gid_t)
     * }
     */
    public static FunctionDescriptor setrgid$descriptor() {
        return setrgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setrgid(gid_t)
     * }
     */
    public static MethodHandle setrgid$handle() {
        return setrgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setrgid(gid_t)
     * }
     */
    public static MemorySegment setrgid$address() {
        return setrgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setrgid(gid_t)
     * }
     */
    public static int setrgid(int x0) {
        var mh$ = setrgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setrgid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setruid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("setruid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setruid(uid_t)
     * }
     */
    public static FunctionDescriptor setruid$descriptor() {
        return setruid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setruid(uid_t)
     * }
     */
    public static MethodHandle setruid$handle() {
        return setruid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setruid(uid_t)
     * }
     */
    public static MemorySegment setruid$address() {
        return setruid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setruid(uid_t)
     * }
     */
    public static int setruid(int x0) {
        var mh$ = setruid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setruid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsgroups_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("setsgroups_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setsgroups_np(int, const uuid_t)
     * }
     */
    public static FunctionDescriptor setsgroups_np$descriptor() {
        return setsgroups_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setsgroups_np(int, const uuid_t)
     * }
     */
    public static MethodHandle setsgroups_np$handle() {
        return setsgroups_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setsgroups_np(int, const uuid_t)
     * }
     */
    public static MemorySegment setsgroups_np$address() {
        return setsgroups_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setsgroups_np(int, const uuid_t)
     * }
     */
    public static int setsgroups_np(int x0, MemorySegment x1) {
        var mh$ = setsgroups_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsgroups_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setusershell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("setusershell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setusershell()
     * }
     */
    public static FunctionDescriptor setusershell$descriptor() {
        return setusershell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setusershell()
     * }
     */
    public static MethodHandle setusershell$handle() {
        return setusershell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setusershell()
     * }
     */
    public static MemorySegment setusershell$address() {
        return setusershell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setusershell()
     * }
     */
    public static void setusershell() {
        var mh$ = setusershell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setusershell");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setwgroups_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("setwgroups_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setwgroups_np(int, const uuid_t)
     * }
     */
    public static FunctionDescriptor setwgroups_np$descriptor() {
        return setwgroups_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setwgroups_np(int, const uuid_t)
     * }
     */
    public static MethodHandle setwgroups_np$handle() {
        return setwgroups_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setwgroups_np(int, const uuid_t)
     * }
     */
    public static MemorySegment setwgroups_np$address() {
        return setwgroups_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setwgroups_np(int, const uuid_t)
     * }
     */
    public static int setwgroups_np(int x0, MemorySegment x1) {
        var mh$ = setwgroups_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setwgroups_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtofflags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("strtofflags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strtofflags(char **, unsigned long *, unsigned long *)
     * }
     */
    public static FunctionDescriptor strtofflags$descriptor() {
        return strtofflags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strtofflags(char **, unsigned long *, unsigned long *)
     * }
     */
    public static MethodHandle strtofflags$handle() {
        return strtofflags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strtofflags(char **, unsigned long *, unsigned long *)
     * }
     */
    public static MemorySegment strtofflags$address() {
        return strtofflags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strtofflags(char **, unsigned long *, unsigned long *)
     * }
     */
    public static int strtofflags(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = strtofflags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtofflags", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swapon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("swapon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int swapon(const char *)
     * }
     */
    public static FunctionDescriptor swapon$descriptor() {
        return swapon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int swapon(const char *)
     * }
     */
    public static MethodHandle swapon$handle() {
        return swapon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int swapon(const char *)
     * }
     */
    public static MemorySegment swapon$address() {
        return swapon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int swapon(const char *)
     * }
     */
    public static int swapon(MemorySegment x0) {
        var mh$ = swapon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swapon", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ttyslot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT    );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("ttyslot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ttyslot()
     * }
     */
    public static FunctionDescriptor ttyslot$descriptor() {
        return ttyslot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ttyslot()
     * }
     */
    public static MethodHandle ttyslot$handle() {
        return ttyslot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ttyslot()
     * }
     */
    public static MemorySegment ttyslot$address() {
        return ttyslot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ttyslot()
     * }
     */
    public static int ttyslot() {
        var mh$ = ttyslot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ttyslot");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class undelete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("undelete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int undelete(const char *)
     * }
     */
    public static FunctionDescriptor undelete$descriptor() {
        return undelete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int undelete(const char *)
     * }
     */
    public static MethodHandle undelete$handle() {
        return undelete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int undelete(const char *)
     * }
     */
    public static MemorySegment undelete$address() {
        return undelete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int undelete(const char *)
     * }
     */
    public static int undelete(MemorySegment x0) {
        var mh$ = undelete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("undelete", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unwhiteout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("unwhiteout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unwhiteout(const char *)
     * }
     */
    public static FunctionDescriptor unwhiteout$descriptor() {
        return unwhiteout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unwhiteout(const char *)
     * }
     */
    public static MethodHandle unwhiteout$handle() {
        return unwhiteout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unwhiteout(const char *)
     * }
     */
    public static MemorySegment unwhiteout$address() {
        return unwhiteout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unwhiteout(const char *)
     * }
     */
    public static int unwhiteout(MemorySegment x0) {
        var mh$ = unwhiteout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unwhiteout", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_POINTER,
            unistd_h.C_LONG
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static FunctionDescriptor valloc$descriptor() {
        return valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static MethodHandle valloc$handle() {
        return valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static MemorySegment valloc$address() {
        return valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static MemorySegment valloc(long x0) {
        var mh$ = valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("valloc", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int syscall(int, ...)
     * }
     */
    public static class syscall {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                unistd_h.C_INT,
                unistd_h.C_INT
            );
        private static final MemorySegment ADDR = unistd_h.findOrThrow("syscall");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private syscall(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int syscall(int, ...)
         * }
         */
        public static syscall makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new syscall(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("syscall", x0, x1);
                }
                return (int) spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class suboptarg$constants {
        public static final AddressLayout LAYOUT = unistd_h.C_POINTER;
        public static final MemorySegment SEGMENT = unistd_h.findOrThrow("suboptarg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static AddressLayout suboptarg$layout() {
        return suboptarg$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg$segment() {
        return suboptarg$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg() {
        return suboptarg$constants.SEGMENT.get(suboptarg$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static void suboptarg(MemorySegment varValue) {
        suboptarg$constants.SEGMENT.set(suboptarg$constants.LAYOUT, 0L, varValue);
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getsubopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MemorySegment getsubopt$address() {
        return getsubopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static int getsubopt(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetattrlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_LONG,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("fgetattrlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static FunctionDescriptor fgetattrlist$descriptor() {
        return fgetattrlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static MethodHandle fgetattrlist$handle() {
        return fgetattrlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static MemorySegment fgetattrlist$address() {
        return fgetattrlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static int fgetattrlist(int x0, MemorySegment x1, MemorySegment x2, long x3, int x4) {
        var mh$ = fgetattrlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetattrlist", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetattrlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_LONG,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("fsetattrlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static FunctionDescriptor fsetattrlist$descriptor() {
        return fsetattrlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static MethodHandle fsetattrlist$handle() {
        return fsetattrlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static MemorySegment fsetattrlist$address() {
        return fsetattrlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static int fsetattrlist(int x0, MemorySegment x1, MemorySegment x2, long x3, int x4) {
        var mh$ = fsetattrlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetattrlist", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getattrlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_LONG,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getattrlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static FunctionDescriptor getattrlist$descriptor() {
        return getattrlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static MethodHandle getattrlist$handle() {
        return getattrlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static MemorySegment getattrlist$address() {
        return getattrlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static int getattrlist(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3, int x4) {
        var mh$ = getattrlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getattrlist", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setattrlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_LONG,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("setattrlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static FunctionDescriptor setattrlist$descriptor() {
        return setattrlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static MethodHandle setattrlist$handle() {
        return setattrlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static MemorySegment setattrlist$address() {
        return setattrlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static int setattrlist(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3, int x4) {
        var mh$ = setattrlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setattrlist", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exchangedata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("exchangedata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int exchangedata(const char *, const char *, unsigned int)
     * }
     */
    public static FunctionDescriptor exchangedata$descriptor() {
        return exchangedata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int exchangedata(const char *, const char *, unsigned int)
     * }
     */
    public static MethodHandle exchangedata$handle() {
        return exchangedata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int exchangedata(const char *, const char *, unsigned int)
     * }
     */
    public static MemorySegment exchangedata$address() {
        return exchangedata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int exchangedata(const char *, const char *, unsigned int)
     * }
     */
    public static int exchangedata(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = exchangedata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exchangedata", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdirentriesattr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_LONG,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("getdirentriesattr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getdirentriesattr(int, void *, void *, size_t, unsigned int *, unsigned int *, unsigned int *, unsigned int)
     * }
     */
    public static FunctionDescriptor getdirentriesattr$descriptor() {
        return getdirentriesattr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getdirentriesattr(int, void *, void *, size_t, unsigned int *, unsigned int *, unsigned int *, unsigned int)
     * }
     */
    public static MethodHandle getdirentriesattr$handle() {
        return getdirentriesattr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getdirentriesattr(int, void *, void *, size_t, unsigned int *, unsigned int *, unsigned int *, unsigned int)
     * }
     */
    public static MemorySegment getdirentriesattr$address() {
        return getdirentriesattr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getdirentriesattr(int, void *, void *, size_t, unsigned int *, unsigned int *, unsigned int *, unsigned int)
     * }
     */
    public static int getdirentriesattr(int x0, MemorySegment x1, MemorySegment x2, long x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, int x7) {
        var mh$ = getdirentriesattr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdirentriesattr", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class searchfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_POINTER,
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_POINTER
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("searchfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *)
     * }
     */
    public static FunctionDescriptor searchfs$descriptor() {
        return searchfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *)
     * }
     */
    public static MethodHandle searchfs$handle() {
        return searchfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *)
     * }
     */
    public static MemorySegment searchfs$address() {
        return searchfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *)
     * }
     */
    public static int searchfs(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5) {
        var mh$ = searchfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("searchfs", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsctl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_LONG,
            unistd_h.C_POINTER,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("fsctl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsctl(const char *, unsigned long, void *, unsigned int)
     * }
     */
    public static FunctionDescriptor fsctl$descriptor() {
        return fsctl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsctl(const char *, unsigned long, void *, unsigned int)
     * }
     */
    public static MethodHandle fsctl$handle() {
        return fsctl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsctl(const char *, unsigned long, void *, unsigned int)
     * }
     */
    public static MemorySegment fsctl$address() {
        return fsctl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsctl(const char *, unsigned long, void *, unsigned int)
     * }
     */
    public static int fsctl(MemorySegment x0, long x1, MemorySegment x2, int x3) {
        var mh$ = fsctl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsctl", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsctl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_LONG,
            unistd_h.C_POINTER,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("ffsctl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffsctl(int, unsigned long, void *, unsigned int)
     * }
     */
    public static FunctionDescriptor ffsctl$descriptor() {
        return ffsctl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffsctl(int, unsigned long, void *, unsigned int)
     * }
     */
    public static MethodHandle ffsctl$handle() {
        return ffsctl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffsctl(int, unsigned long, void *, unsigned int)
     * }
     */
    public static MemorySegment ffsctl$address() {
        return ffsctl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffsctl(int, unsigned long, void *, unsigned int)
     * }
     */
    public static int ffsctl(int x0, long x1, MemorySegment x2, int x3) {
        var mh$ = ffsctl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsctl", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsync_volume_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_INT,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("fsync_volume_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsync_volume_np(int, int)
     * }
     */
    public static FunctionDescriptor fsync_volume_np$descriptor() {
        return fsync_volume_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsync_volume_np(int, int)
     * }
     */
    public static MethodHandle fsync_volume_np$handle() {
        return fsync_volume_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsync_volume_np(int, int)
     * }
     */
    public static MemorySegment fsync_volume_np$address() {
        return fsync_volume_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsync_volume_np(int, int)
     * }
     */
    public static int fsync_volume_np(int x0, int x1) {
        var mh$ = fsync_volume_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsync_volume_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sync_volume_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            unistd_h.C_INT,
            unistd_h.C_POINTER,
            unistd_h.C_INT
        );

        public static final MemorySegment ADDR = unistd_h.findOrThrow("sync_volume_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sync_volume_np(const char *, int)
     * }
     */
    public static FunctionDescriptor sync_volume_np$descriptor() {
        return sync_volume_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sync_volume_np(const char *, int)
     * }
     */
    public static MethodHandle sync_volume_np$handle() {
        return sync_volume_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sync_volume_np(const char *, int)
     * }
     */
    public static MemorySegment sync_volume_np$address() {
        return sync_volume_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sync_volume_np(const char *, int)
     * }
     */
    public static int sync_volume_np(MemorySegment x0, int x1) {
        var mh$ = sync_volume_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sync_volume_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class optreset$constants {
        public static final OfInt LAYOUT = unistd_h.C_INT;
        public static final MemorySegment SEGMENT = unistd_h.findOrThrow("optreset").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int optreset
     * }
     */
    public static OfInt optreset$layout() {
        return optreset$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int optreset
     * }
     */
    public static MemorySegment optreset$segment() {
        return optreset$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int optreset
     * }
     */
    public static int optreset() {
        return optreset$constants.SEGMENT.get(optreset$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int optreset
     * }
     */
    public static void optreset(int varValue) {
        optreset$constants.SEGMENT.set(optreset$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * #define __DARWIN_SUF_64_BIT_INO_T "$INODE64"
     * }
     */
    public static MemorySegment __DARWIN_SUF_64_BIT_INO_T() {
        class Holder {
            static final MemorySegment __DARWIN_SUF_64_BIT_INO_T
                = unistd_h.LIBRARY_ARENA.allocateFrom("$INODE64");
        }
        return Holder.__DARWIN_SUF_64_BIT_INO_T;
    }
    /**
     * {@snippet lang=c :
     * #define __DARWIN_SUF_1050 "$1050"
     * }
     */
    public static MemorySegment __DARWIN_SUF_1050() {
        class Holder {
            static final MemorySegment __DARWIN_SUF_1050
                = unistd_h.LIBRARY_ARENA.allocateFrom("$1050");
        }
        return Holder.__DARWIN_SUF_1050;
    }
    /**
     * {@snippet lang=c :
     * #define __DARWIN_SUF_EXTSN "$DARWIN_EXTSN"
     * }
     */
    public static MemorySegment __DARWIN_SUF_EXTSN() {
        class Holder {
            static final MemorySegment __DARWIN_SUF_EXTSN
                = unistd_h.LIBRARY_ARENA.allocateFrom("$DARWIN_EXTSN");
        }
        return Holder.__DARWIN_SUF_EXTSN;
    }
    private static final long __DARWIN_C_ANSI = 4096L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_ANSI 4096
     * }
     */
    public static long __DARWIN_C_ANSI() {
        return __DARWIN_C_ANSI;
    }
    private static final long __DARWIN_C_FULL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_FULL 900000
     * }
     */
    public static long __DARWIN_C_FULL() {
        return __DARWIN_C_FULL;
    }
    private static final long __DARWIN_C_LEVEL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_LEVEL 900000
     * }
     */
    public static long __DARWIN_C_LEVEL() {
        return __DARWIN_C_LEVEL;
    }
    private static final MemorySegment __DARWIN_NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NULL (void*) 0
     * }
     */
    public static MemorySegment __DARWIN_NULL() {
        return __DARWIN_NULL;
    }
    private static final int __DARWIN_WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WCHAR_MAX 2147483647
     * }
     */
    public static int __DARWIN_WCHAR_MAX() {
        return __DARWIN_WCHAR_MAX;
    }
    private static final int __DARWIN_WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WCHAR_MIN -2147483648
     * }
     */
    public static int __DARWIN_WCHAR_MIN() {
        return __DARWIN_WCHAR_MIN;
    }
    private static final int __DARWIN_WEOF = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WEOF -1
     * }
     */
    public static int __DARWIN_WEOF() {
        return __DARWIN_WEOF;
    }
    private static final long _POSIX_VERSION = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_VERSION 200112
     * }
     */
    public static long _POSIX_VERSION() {
        return _POSIX_VERSION;
    }
    private static final long _POSIX2_VERSION = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_VERSION 200112
     * }
     */
    public static long _POSIX2_VERSION() {
        return _POSIX2_VERSION;
    }
    private static final byte _POSIX_VDISABLE = (byte)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_VDISABLE 255
     * }
     */
    public static byte _POSIX_VDISABLE() {
        return _POSIX_VDISABLE;
    }
    private static final int X_OK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define X_OK 1
     * }
     */
    public static int X_OK() {
        return X_OK;
    }
    private static final int W_OK = (int)2L;
    /**
     * {@snippet lang=c :
     * #define W_OK 2
     * }
     */
    public static int W_OK() {
        return W_OK;
    }
    private static final int R_OK = (int)4L;
    /**
     * {@snippet lang=c :
     * #define R_OK 4
     * }
     */
    public static int R_OK() {
        return R_OK;
    }
    private static final int _READ_OK = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _READ_OK 512
     * }
     */
    public static int _READ_OK() {
        return _READ_OK;
    }
    private static final int _WRITE_OK = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define _WRITE_OK 1024
     * }
     */
    public static int _WRITE_OK() {
        return _WRITE_OK;
    }
    private static final int _EXECUTE_OK = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define _EXECUTE_OK 2048
     * }
     */
    public static int _EXECUTE_OK() {
        return _EXECUTE_OK;
    }
    private static final int _DELETE_OK = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define _DELETE_OK 4096
     * }
     */
    public static int _DELETE_OK() {
        return _DELETE_OK;
    }
    private static final int _APPEND_OK = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define _APPEND_OK 8192
     * }
     */
    public static int _APPEND_OK() {
        return _APPEND_OK;
    }
    private static final int _RMFILE_OK = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define _RMFILE_OK 16384
     * }
     */
    public static int _RMFILE_OK() {
        return _RMFILE_OK;
    }
    private static final int _RATTR_OK = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define _RATTR_OK 32768
     * }
     */
    public static int _RATTR_OK() {
        return _RATTR_OK;
    }
    private static final int _WATTR_OK = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define _WATTR_OK 65536
     * }
     */
    public static int _WATTR_OK() {
        return _WATTR_OK;
    }
    private static final int _REXT_OK = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define _REXT_OK 131072
     * }
     */
    public static int _REXT_OK() {
        return _REXT_OK;
    }
    private static final int _WEXT_OK = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define _WEXT_OK 262144
     * }
     */
    public static int _WEXT_OK() {
        return _WEXT_OK;
    }
    private static final int _RPERM_OK = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define _RPERM_OK 524288
     * }
     */
    public static int _RPERM_OK() {
        return _RPERM_OK;
    }
    private static final int _WPERM_OK = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define _WPERM_OK 1048576
     * }
     */
    public static int _WPERM_OK() {
        return _WPERM_OK;
    }
    private static final int _CHOWN_OK = (int)2097152L;
    /**
     * {@snippet lang=c :
     * #define _CHOWN_OK 2097152
     * }
     */
    public static int _CHOWN_OK() {
        return _CHOWN_OK;
    }
    private static final int _ACCESS_EXTENDED_MASK = (int)4193792L;
    /**
     * {@snippet lang=c :
     * #define _ACCESS_EXTENDED_MASK 4193792
     * }
     */
    public static int _ACCESS_EXTENDED_MASK() {
        return _ACCESS_EXTENDED_MASK;
    }
    private static final int L_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define L_SET 0
     * }
     */
    public static int L_SET() {
        return L_SET;
    }
    private static final int L_INCR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define L_INCR 1
     * }
     */
    public static int L_INCR() {
        return L_INCR;
    }
    private static final int L_XTND = (int)2L;
    /**
     * {@snippet lang=c :
     * #define L_XTND 2
     * }
     */
    public static int L_XTND() {
        return L_XTND;
    }
    private static final int ACCESSX_MAX_TABLESIZE = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define ACCESSX_MAX_TABLESIZE 16384
     * }
     */
    public static int ACCESSX_MAX_TABLESIZE() {
        return ACCESSX_MAX_TABLESIZE;
    }
    private static final long USER_ADDR_NULL = 0L;
    /**
     * {@snippet lang=c :
     * #define USER_ADDR_NULL 0
     * }
     */
    public static long USER_ADDR_NULL() {
        return USER_ADDR_NULL;
    }
    private static final int MAC_OS_X_VERSION_10_0 = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_0 1000
     * }
     */
    public static int MAC_OS_X_VERSION_10_0() {
        return MAC_OS_X_VERSION_10_0;
    }
    private static final int MAC_OS_X_VERSION_10_1 = (int)1010L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_1 1010
     * }
     */
    public static int MAC_OS_X_VERSION_10_1() {
        return MAC_OS_X_VERSION_10_1;
    }
    private static final int MAC_OS_X_VERSION_10_2 = (int)1020L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_2 1020
     * }
     */
    public static int MAC_OS_X_VERSION_10_2() {
        return MAC_OS_X_VERSION_10_2;
    }
    private static final int MAC_OS_X_VERSION_10_3 = (int)1030L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_3 1030
     * }
     */
    public static int MAC_OS_X_VERSION_10_3() {
        return MAC_OS_X_VERSION_10_3;
    }
    private static final int MAC_OS_X_VERSION_10_4 = (int)1040L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_4 1040
     * }
     */
    public static int MAC_OS_X_VERSION_10_4() {
        return MAC_OS_X_VERSION_10_4;
    }
    private static final int MAC_OS_X_VERSION_10_5 = (int)1050L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_5 1050
     * }
     */
    public static int MAC_OS_X_VERSION_10_5() {
        return MAC_OS_X_VERSION_10_5;
    }
    private static final int MAC_OS_X_VERSION_10_6 = (int)1060L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_6 1060
     * }
     */
    public static int MAC_OS_X_VERSION_10_6() {
        return MAC_OS_X_VERSION_10_6;
    }
    private static final int MAC_OS_X_VERSION_10_7 = (int)1070L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_7 1070
     * }
     */
    public static int MAC_OS_X_VERSION_10_7() {
        return MAC_OS_X_VERSION_10_7;
    }
    private static final int MAC_OS_X_VERSION_10_8 = (int)1080L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_8 1080
     * }
     */
    public static int MAC_OS_X_VERSION_10_8() {
        return MAC_OS_X_VERSION_10_8;
    }
    private static final int MAC_OS_X_VERSION_10_9 = (int)1090L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_9 1090
     * }
     */
    public static int MAC_OS_X_VERSION_10_9() {
        return MAC_OS_X_VERSION_10_9;
    }
    private static final int MAC_OS_X_VERSION_10_10 = (int)101000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10 101000
     * }
     */
    public static int MAC_OS_X_VERSION_10_10() {
        return MAC_OS_X_VERSION_10_10;
    }
    private static final int MAC_OS_X_VERSION_10_10_2 = (int)101002L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_2 101002
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_2() {
        return MAC_OS_X_VERSION_10_10_2;
    }
    private static final int MAC_OS_X_VERSION_10_10_3 = (int)101003L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_3 101003
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_3() {
        return MAC_OS_X_VERSION_10_10_3;
    }
    private static final int MAC_OS_X_VERSION_10_11 = (int)101100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11 101100
     * }
     */
    public static int MAC_OS_X_VERSION_10_11() {
        return MAC_OS_X_VERSION_10_11;
    }
    private static final int MAC_OS_X_VERSION_10_11_2 = (int)101102L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_2 101102
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_2() {
        return MAC_OS_X_VERSION_10_11_2;
    }
    private static final int MAC_OS_X_VERSION_10_11_3 = (int)101103L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_3 101103
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_3() {
        return MAC_OS_X_VERSION_10_11_3;
    }
    private static final int MAC_OS_X_VERSION_10_11_4 = (int)101104L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_4 101104
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_4() {
        return MAC_OS_X_VERSION_10_11_4;
    }
    private static final int MAC_OS_X_VERSION_10_12 = (int)101200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12 101200
     * }
     */
    public static int MAC_OS_X_VERSION_10_12() {
        return MAC_OS_X_VERSION_10_12;
    }
    private static final int MAC_OS_X_VERSION_10_12_1 = (int)101201L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_1 101201
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_1() {
        return MAC_OS_X_VERSION_10_12_1;
    }
    private static final int MAC_OS_X_VERSION_10_12_2 = (int)101202L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_2 101202
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_2() {
        return MAC_OS_X_VERSION_10_12_2;
    }
    private static final int MAC_OS_X_VERSION_10_12_4 = (int)101204L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_4 101204
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_4() {
        return MAC_OS_X_VERSION_10_12_4;
    }
    private static final int MAC_OS_X_VERSION_10_13 = (int)101300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13 101300
     * }
     */
    public static int MAC_OS_X_VERSION_10_13() {
        return MAC_OS_X_VERSION_10_13;
    }
    private static final int MAC_OS_X_VERSION_10_13_1 = (int)101301L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_1 101301
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_1() {
        return MAC_OS_X_VERSION_10_13_1;
    }
    private static final int MAC_OS_X_VERSION_10_13_2 = (int)101302L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_2 101302
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_2() {
        return MAC_OS_X_VERSION_10_13_2;
    }
    private static final int MAC_OS_X_VERSION_10_13_4 = (int)101304L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_4 101304
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_4() {
        return MAC_OS_X_VERSION_10_13_4;
    }
    private static final int MAC_OS_X_VERSION_10_14 = (int)101400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14 101400
     * }
     */
    public static int MAC_OS_X_VERSION_10_14() {
        return MAC_OS_X_VERSION_10_14;
    }
    private static final int MAC_OS_X_VERSION_10_14_1 = (int)101401L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_1 101401
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_1() {
        return MAC_OS_X_VERSION_10_14_1;
    }
    private static final int MAC_OS_X_VERSION_10_14_4 = (int)101404L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_4 101404
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_4() {
        return MAC_OS_X_VERSION_10_14_4;
    }
    private static final int MAC_OS_X_VERSION_10_14_5 = (int)101405L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_5 101405
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_5() {
        return MAC_OS_X_VERSION_10_14_5;
    }
    private static final int MAC_OS_X_VERSION_10_14_6 = (int)101406L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_6 101406
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_6() {
        return MAC_OS_X_VERSION_10_14_6;
    }
    private static final int MAC_OS_X_VERSION_10_15 = (int)101500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15 101500
     * }
     */
    public static int MAC_OS_X_VERSION_10_15() {
        return MAC_OS_X_VERSION_10_15;
    }
    private static final int MAC_OS_X_VERSION_10_15_1 = (int)101501L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_1 101501
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_1() {
        return MAC_OS_X_VERSION_10_15_1;
    }
    private static final int MAC_OS_X_VERSION_10_15_4 = (int)101504L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_4 101504
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_4() {
        return MAC_OS_X_VERSION_10_15_4;
    }
    private static final int MAC_OS_X_VERSION_10_16 = (int)101600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_16 101600
     * }
     */
    public static int MAC_OS_X_VERSION_10_16() {
        return MAC_OS_X_VERSION_10_16;
    }
    private static final int MAC_OS_VERSION_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_0 110000
     * }
     */
    public static int MAC_OS_VERSION_11_0() {
        return MAC_OS_VERSION_11_0;
    }
    private static final int MAC_OS_VERSION_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_1 110100
     * }
     */
    public static int MAC_OS_VERSION_11_1() {
        return MAC_OS_VERSION_11_1;
    }
    private static final int MAC_OS_VERSION_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_3 110300
     * }
     */
    public static int MAC_OS_VERSION_11_3() {
        return MAC_OS_VERSION_11_3;
    }
    private static final int MAC_OS_VERSION_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_4 110400
     * }
     */
    public static int MAC_OS_VERSION_11_4() {
        return MAC_OS_VERSION_11_4;
    }
    private static final int MAC_OS_VERSION_11_5 = (int)110500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_5 110500
     * }
     */
    public static int MAC_OS_VERSION_11_5() {
        return MAC_OS_VERSION_11_5;
    }
    private static final int MAC_OS_VERSION_11_6 = (int)110600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_6 110600
     * }
     */
    public static int MAC_OS_VERSION_11_6() {
        return MAC_OS_VERSION_11_6;
    }
    private static final int MAC_OS_VERSION_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_0 120000
     * }
     */
    public static int MAC_OS_VERSION_12_0() {
        return MAC_OS_VERSION_12_0;
    }
    private static final int MAC_OS_VERSION_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_1 120100
     * }
     */
    public static int MAC_OS_VERSION_12_1() {
        return MAC_OS_VERSION_12_1;
    }
    private static final int MAC_OS_VERSION_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_2 120200
     * }
     */
    public static int MAC_OS_VERSION_12_2() {
        return MAC_OS_VERSION_12_2;
    }
    private static final int MAC_OS_VERSION_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_3 120300
     * }
     */
    public static int MAC_OS_VERSION_12_3() {
        return MAC_OS_VERSION_12_3;
    }
    private static final int MAC_OS_VERSION_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_4 120400
     * }
     */
    public static int MAC_OS_VERSION_12_4() {
        return MAC_OS_VERSION_12_4;
    }
    private static final int MAC_OS_VERSION_12_5 = (int)120500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_5 120500
     * }
     */
    public static int MAC_OS_VERSION_12_5() {
        return MAC_OS_VERSION_12_5;
    }
    private static final int MAC_OS_VERSION_12_6 = (int)120600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_6 120600
     * }
     */
    public static int MAC_OS_VERSION_12_6() {
        return MAC_OS_VERSION_12_6;
    }
    private static final int MAC_OS_VERSION_12_7 = (int)120700L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_7 120700
     * }
     */
    public static int MAC_OS_VERSION_12_7() {
        return MAC_OS_VERSION_12_7;
    }
    private static final int MAC_OS_VERSION_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_0 130000
     * }
     */
    public static int MAC_OS_VERSION_13_0() {
        return MAC_OS_VERSION_13_0;
    }
    private static final int MAC_OS_VERSION_13_1 = (int)130100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_1 130100
     * }
     */
    public static int MAC_OS_VERSION_13_1() {
        return MAC_OS_VERSION_13_1;
    }
    private static final int MAC_OS_VERSION_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_2 130200
     * }
     */
    public static int MAC_OS_VERSION_13_2() {
        return MAC_OS_VERSION_13_2;
    }
    private static final int MAC_OS_VERSION_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_3 130300
     * }
     */
    public static int MAC_OS_VERSION_13_3() {
        return MAC_OS_VERSION_13_3;
    }
    private static final int MAC_OS_VERSION_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_4 130400
     * }
     */
    public static int MAC_OS_VERSION_13_4() {
        return MAC_OS_VERSION_13_4;
    }
    private static final int MAC_OS_VERSION_13_5 = (int)130500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_5 130500
     * }
     */
    public static int MAC_OS_VERSION_13_5() {
        return MAC_OS_VERSION_13_5;
    }
    private static final int MAC_OS_VERSION_13_6 = (int)130600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_6 130600
     * }
     */
    public static int MAC_OS_VERSION_13_6() {
        return MAC_OS_VERSION_13_6;
    }
    private static final int MAC_OS_VERSION_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_0 140000
     * }
     */
    public static int MAC_OS_VERSION_14_0() {
        return MAC_OS_VERSION_14_0;
    }
    private static final int MAC_OS_VERSION_14_1 = (int)140100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_1 140100
     * }
     */
    public static int MAC_OS_VERSION_14_1() {
        return MAC_OS_VERSION_14_1;
    }
    private static final int MAC_OS_VERSION_14_2 = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_2 140200
     * }
     */
    public static int MAC_OS_VERSION_14_2() {
        return MAC_OS_VERSION_14_2;
    }
    private static final int MAC_OS_VERSION_14_3 = (int)140300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_3 140300
     * }
     */
    public static int MAC_OS_VERSION_14_3() {
        return MAC_OS_VERSION_14_3;
    }
    private static final int MAC_OS_VERSION_14_4 = (int)140400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_4 140400
     * }
     */
    public static int MAC_OS_VERSION_14_4() {
        return MAC_OS_VERSION_14_4;
    }
    private static final int MAC_OS_VERSION_14_5 = (int)140500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_5 140500
     * }
     */
    public static int MAC_OS_VERSION_14_5() {
        return MAC_OS_VERSION_14_5;
    }
    private static final int MAC_OS_VERSION_15_0 = (int)150000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_0 150000
     * }
     */
    public static int MAC_OS_VERSION_15_0() {
        return MAC_OS_VERSION_15_0;
    }
    private static final int MAC_OS_VERSION_15_1 = (int)150100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_1 150100
     * }
     */
    public static int MAC_OS_VERSION_15_1() {
        return MAC_OS_VERSION_15_1;
    }
    private static final int MAC_OS_VERSION_15_2 = (int)150200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_2 150200
     * }
     */
    public static int MAC_OS_VERSION_15_2() {
        return MAC_OS_VERSION_15_2;
    }
    private static final int __MAC_OS_X_VERSION_MAX_ALLOWED = (int)150200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_OS_X_VERSION_MAX_ALLOWED 150200
     * }
     */
    public static int __MAC_OS_X_VERSION_MAX_ALLOWED() {
        return __MAC_OS_X_VERSION_MAX_ALLOWED;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final int _POSIX_ADVISORY_INFO = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_ADVISORY_INFO -1
     * }
     */
    public static int _POSIX_ADVISORY_INFO() {
        return _POSIX_ADVISORY_INFO;
    }
    private static final int _POSIX_ASYNCHRONOUS_IO = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_ASYNCHRONOUS_IO -1
     * }
     */
    public static int _POSIX_ASYNCHRONOUS_IO() {
        return _POSIX_ASYNCHRONOUS_IO;
    }
    private static final int _POSIX_BARRIERS = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_BARRIERS -1
     * }
     */
    public static int _POSIX_BARRIERS() {
        return _POSIX_BARRIERS;
    }
    private static final long _POSIX_CHOWN_RESTRICTED = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_CHOWN_RESTRICTED 200112
     * }
     */
    public static long _POSIX_CHOWN_RESTRICTED() {
        return _POSIX_CHOWN_RESTRICTED;
    }
    private static final int _POSIX_CLOCK_SELECTION = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_CLOCK_SELECTION -1
     * }
     */
    public static int _POSIX_CLOCK_SELECTION() {
        return _POSIX_CLOCK_SELECTION;
    }
    private static final int _POSIX_CPUTIME = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_CPUTIME -1
     * }
     */
    public static int _POSIX_CPUTIME() {
        return _POSIX_CPUTIME;
    }
    private static final long _POSIX_FSYNC = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_FSYNC 200112
     * }
     */
    public static long _POSIX_FSYNC() {
        return _POSIX_FSYNC;
    }
    private static final long _POSIX_IPV6 = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_IPV6 200112
     * }
     */
    public static long _POSIX_IPV6() {
        return _POSIX_IPV6;
    }
    private static final long _POSIX_JOB_CONTROL = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_JOB_CONTROL 200112
     * }
     */
    public static long _POSIX_JOB_CONTROL() {
        return _POSIX_JOB_CONTROL;
    }
    private static final long _POSIX_MAPPED_FILES = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MAPPED_FILES 200112
     * }
     */
    public static long _POSIX_MAPPED_FILES() {
        return _POSIX_MAPPED_FILES;
    }
    private static final int _POSIX_MEMLOCK = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MEMLOCK -1
     * }
     */
    public static int _POSIX_MEMLOCK() {
        return _POSIX_MEMLOCK;
    }
    private static final int _POSIX_MEMLOCK_RANGE = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MEMLOCK_RANGE -1
     * }
     */
    public static int _POSIX_MEMLOCK_RANGE() {
        return _POSIX_MEMLOCK_RANGE;
    }
    private static final long _POSIX_MEMORY_PROTECTION = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MEMORY_PROTECTION 200112
     * }
     */
    public static long _POSIX_MEMORY_PROTECTION() {
        return _POSIX_MEMORY_PROTECTION;
    }
    private static final int _POSIX_MESSAGE_PASSING = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MESSAGE_PASSING -1
     * }
     */
    public static int _POSIX_MESSAGE_PASSING() {
        return _POSIX_MESSAGE_PASSING;
    }
    private static final int _POSIX_MONOTONIC_CLOCK = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MONOTONIC_CLOCK -1
     * }
     */
    public static int _POSIX_MONOTONIC_CLOCK() {
        return _POSIX_MONOTONIC_CLOCK;
    }
    private static final long _POSIX_NO_TRUNC = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_NO_TRUNC 200112
     * }
     */
    public static long _POSIX_NO_TRUNC() {
        return _POSIX_NO_TRUNC;
    }
    private static final int _POSIX_PRIORITIZED_IO = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_PRIORITIZED_IO -1
     * }
     */
    public static int _POSIX_PRIORITIZED_IO() {
        return _POSIX_PRIORITIZED_IO;
    }
    private static final int _POSIX_PRIORITY_SCHEDULING = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_PRIORITY_SCHEDULING -1
     * }
     */
    public static int _POSIX_PRIORITY_SCHEDULING() {
        return _POSIX_PRIORITY_SCHEDULING;
    }
    private static final int _POSIX_RAW_SOCKETS = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_RAW_SOCKETS -1
     * }
     */
    public static int _POSIX_RAW_SOCKETS() {
        return _POSIX_RAW_SOCKETS;
    }
    private static final long _POSIX_READER_WRITER_LOCKS = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_READER_WRITER_LOCKS 200112
     * }
     */
    public static long _POSIX_READER_WRITER_LOCKS() {
        return _POSIX_READER_WRITER_LOCKS;
    }
    private static final int _POSIX_REALTIME_SIGNALS = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_REALTIME_SIGNALS -1
     * }
     */
    public static int _POSIX_REALTIME_SIGNALS() {
        return _POSIX_REALTIME_SIGNALS;
    }
    private static final long _POSIX_REGEXP = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_REGEXP 200112
     * }
     */
    public static long _POSIX_REGEXP() {
        return _POSIX_REGEXP;
    }
    private static final long _POSIX_SAVED_IDS = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SAVED_IDS 200112
     * }
     */
    public static long _POSIX_SAVED_IDS() {
        return _POSIX_SAVED_IDS;
    }
    private static final int _POSIX_SEMAPHORES = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SEMAPHORES -1
     * }
     */
    public static int _POSIX_SEMAPHORES() {
        return _POSIX_SEMAPHORES;
    }
    private static final int _POSIX_SHARED_MEMORY_OBJECTS = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SHARED_MEMORY_OBJECTS -1
     * }
     */
    public static int _POSIX_SHARED_MEMORY_OBJECTS() {
        return _POSIX_SHARED_MEMORY_OBJECTS;
    }
    private static final long _POSIX_SHELL = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SHELL 200112
     * }
     */
    public static long _POSIX_SHELL() {
        return _POSIX_SHELL;
    }
    private static final long _POSIX_SPAWN = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SPAWN 200112
     * }
     */
    public static long _POSIX_SPAWN() {
        return _POSIX_SPAWN;
    }
    private static final int _POSIX_SPIN_LOCKS = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SPIN_LOCKS -1
     * }
     */
    public static int _POSIX_SPIN_LOCKS() {
        return _POSIX_SPIN_LOCKS;
    }
    private static final int _POSIX_SPORADIC_SERVER = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SPORADIC_SERVER -1
     * }
     */
    public static int _POSIX_SPORADIC_SERVER() {
        return _POSIX_SPORADIC_SERVER;
    }
    private static final int _POSIX_SYNCHRONIZED_IO = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SYNCHRONIZED_IO -1
     * }
     */
    public static int _POSIX_SYNCHRONIZED_IO() {
        return _POSIX_SYNCHRONIZED_IO;
    }
    private static final long _POSIX_THREAD_ATTR_STACKADDR = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_ATTR_STACKADDR 200112
     * }
     */
    public static long _POSIX_THREAD_ATTR_STACKADDR() {
        return _POSIX_THREAD_ATTR_STACKADDR;
    }
    private static final long _POSIX_THREAD_ATTR_STACKSIZE = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_ATTR_STACKSIZE 200112
     * }
     */
    public static long _POSIX_THREAD_ATTR_STACKSIZE() {
        return _POSIX_THREAD_ATTR_STACKSIZE;
    }
    private static final int _POSIX_THREAD_CPUTIME = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_CPUTIME -1
     * }
     */
    public static int _POSIX_THREAD_CPUTIME() {
        return _POSIX_THREAD_CPUTIME;
    }
    private static final int _POSIX_THREAD_PRIO_INHERIT = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_PRIO_INHERIT -1
     * }
     */
    public static int _POSIX_THREAD_PRIO_INHERIT() {
        return _POSIX_THREAD_PRIO_INHERIT;
    }
    private static final int _POSIX_THREAD_PRIO_PROTECT = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_PRIO_PROTECT -1
     * }
     */
    public static int _POSIX_THREAD_PRIO_PROTECT() {
        return _POSIX_THREAD_PRIO_PROTECT;
    }
    private static final int _POSIX_THREAD_PRIORITY_SCHEDULING = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_PRIORITY_SCHEDULING -1
     * }
     */
    public static int _POSIX_THREAD_PRIORITY_SCHEDULING() {
        return _POSIX_THREAD_PRIORITY_SCHEDULING;
    }
    private static final long _POSIX_THREAD_PROCESS_SHARED = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_PROCESS_SHARED 200112
     * }
     */
    public static long _POSIX_THREAD_PROCESS_SHARED() {
        return _POSIX_THREAD_PROCESS_SHARED;
    }
    private static final long _POSIX_THREAD_SAFE_FUNCTIONS = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_SAFE_FUNCTIONS 200112
     * }
     */
    public static long _POSIX_THREAD_SAFE_FUNCTIONS() {
        return _POSIX_THREAD_SAFE_FUNCTIONS;
    }
    private static final int _POSIX_THREAD_SPORADIC_SERVER = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_SPORADIC_SERVER -1
     * }
     */
    public static int _POSIX_THREAD_SPORADIC_SERVER() {
        return _POSIX_THREAD_SPORADIC_SERVER;
    }
    private static final long _POSIX_THREADS = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREADS 200112
     * }
     */
    public static long _POSIX_THREADS() {
        return _POSIX_THREADS;
    }
    private static final int _POSIX_TIMEOUTS = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TIMEOUTS -1
     * }
     */
    public static int _POSIX_TIMEOUTS() {
        return _POSIX_TIMEOUTS;
    }
    private static final int _POSIX_TIMERS = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TIMERS -1
     * }
     */
    public static int _POSIX_TIMERS() {
        return _POSIX_TIMERS;
    }
    private static final int _POSIX_TRACE = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TRACE -1
     * }
     */
    public static int _POSIX_TRACE() {
        return _POSIX_TRACE;
    }
    private static final int _POSIX_TRACE_EVENT_FILTER = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TRACE_EVENT_FILTER -1
     * }
     */
    public static int _POSIX_TRACE_EVENT_FILTER() {
        return _POSIX_TRACE_EVENT_FILTER;
    }
    private static final int _POSIX_TRACE_INHERIT = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TRACE_INHERIT -1
     * }
     */
    public static int _POSIX_TRACE_INHERIT() {
        return _POSIX_TRACE_INHERIT;
    }
    private static final int _POSIX_TRACE_LOG = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TRACE_LOG -1
     * }
     */
    public static int _POSIX_TRACE_LOG() {
        return _POSIX_TRACE_LOG;
    }
    private static final int _POSIX_TYPED_MEMORY_OBJECTS = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TYPED_MEMORY_OBJECTS -1
     * }
     */
    public static int _POSIX_TYPED_MEMORY_OBJECTS() {
        return _POSIX_TYPED_MEMORY_OBJECTS;
    }
    private static final long _POSIX2_C_BIND = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_C_BIND 200112
     * }
     */
    public static long _POSIX2_C_BIND() {
        return _POSIX2_C_BIND;
    }
    private static final long _POSIX2_C_DEV = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_C_DEV 200112
     * }
     */
    public static long _POSIX2_C_DEV() {
        return _POSIX2_C_DEV;
    }
    private static final long _POSIX2_CHAR_TERM = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_CHAR_TERM 200112
     * }
     */
    public static long _POSIX2_CHAR_TERM() {
        return _POSIX2_CHAR_TERM;
    }
    private static final int _POSIX2_FORT_DEV = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_FORT_DEV -1
     * }
     */
    public static int _POSIX2_FORT_DEV() {
        return _POSIX2_FORT_DEV;
    }
    private static final long _POSIX2_FORT_RUN = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_FORT_RUN 200112
     * }
     */
    public static long _POSIX2_FORT_RUN() {
        return _POSIX2_FORT_RUN;
    }
    private static final long _POSIX2_LOCALEDEF = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_LOCALEDEF 200112
     * }
     */
    public static long _POSIX2_LOCALEDEF() {
        return _POSIX2_LOCALEDEF;
    }
    private static final int _POSIX2_PBS = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_PBS -1
     * }
     */
    public static int _POSIX2_PBS() {
        return _POSIX2_PBS;
    }
    private static final int _POSIX2_PBS_ACCOUNTING = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_PBS_ACCOUNTING -1
     * }
     */
    public static int _POSIX2_PBS_ACCOUNTING() {
        return _POSIX2_PBS_ACCOUNTING;
    }
    private static final int _POSIX2_PBS_CHECKPOINT = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_PBS_CHECKPOINT -1
     * }
     */
    public static int _POSIX2_PBS_CHECKPOINT() {
        return _POSIX2_PBS_CHECKPOINT;
    }
    private static final int _POSIX2_PBS_LOCATE = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_PBS_LOCATE -1
     * }
     */
    public static int _POSIX2_PBS_LOCATE() {
        return _POSIX2_PBS_LOCATE;
    }
    private static final int _POSIX2_PBS_MESSAGE = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_PBS_MESSAGE -1
     * }
     */
    public static int _POSIX2_PBS_MESSAGE() {
        return _POSIX2_PBS_MESSAGE;
    }
    private static final int _POSIX2_PBS_TRACK = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_PBS_TRACK -1
     * }
     */
    public static int _POSIX2_PBS_TRACK() {
        return _POSIX2_PBS_TRACK;
    }
    private static final long _POSIX2_SW_DEV = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_SW_DEV 200112
     * }
     */
    public static long _POSIX2_SW_DEV() {
        return _POSIX2_SW_DEV;
    }
    private static final long _POSIX2_UPE = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_UPE 200112
     * }
     */
    public static long _POSIX2_UPE() {
        return _POSIX2_UPE;
    }
    private static final int __ILP32_OFF32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define __ILP32_OFF32 -1
     * }
     */
    public static int __ILP32_OFF32() {
        return __ILP32_OFF32;
    }
    private static final int __ILP32_OFFBIG = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define __ILP32_OFFBIG -1
     * }
     */
    public static int __ILP32_OFFBIG() {
        return __ILP32_OFFBIG;
    }
    private static final int __LP64_OFF64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __LP64_OFF64 1
     * }
     */
    public static int __LP64_OFF64() {
        return __LP64_OFF64;
    }
    private static final int __LPBIG_OFFBIG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __LPBIG_OFFBIG 1
     * }
     */
    public static int __LPBIG_OFFBIG() {
        return __LPBIG_OFFBIG;
    }
    private static final int _POSIX_V6_ILP32_OFF32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_V6_ILP32_OFF32 -1
     * }
     */
    public static int _POSIX_V6_ILP32_OFF32() {
        return _POSIX_V6_ILP32_OFF32;
    }
    private static final int _POSIX_V6_ILP32_OFFBIG = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_V6_ILP32_OFFBIG -1
     * }
     */
    public static int _POSIX_V6_ILP32_OFFBIG() {
        return _POSIX_V6_ILP32_OFFBIG;
    }
    private static final int _POSIX_V6_LP64_OFF64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_V6_LP64_OFF64 1
     * }
     */
    public static int _POSIX_V6_LP64_OFF64() {
        return _POSIX_V6_LP64_OFF64;
    }
    private static final int _POSIX_V6_LPBIG_OFFBIG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_V6_LPBIG_OFFBIG 1
     * }
     */
    public static int _POSIX_V6_LPBIG_OFFBIG() {
        return _POSIX_V6_LPBIG_OFFBIG;
    }
    private static final int _POSIX_V7_ILP32_OFF32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_V7_ILP32_OFF32 -1
     * }
     */
    public static int _POSIX_V7_ILP32_OFF32() {
        return _POSIX_V7_ILP32_OFF32;
    }
    private static final int _POSIX_V7_ILP32_OFFBIG = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_V7_ILP32_OFFBIG -1
     * }
     */
    public static int _POSIX_V7_ILP32_OFFBIG() {
        return _POSIX_V7_ILP32_OFFBIG;
    }
    private static final int _POSIX_V7_LP64_OFF64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_V7_LP64_OFF64 1
     * }
     */
    public static int _POSIX_V7_LP64_OFF64() {
        return _POSIX_V7_LP64_OFF64;
    }
    private static final int _POSIX_V7_LPBIG_OFFBIG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_V7_LPBIG_OFFBIG 1
     * }
     */
    public static int _POSIX_V7_LPBIG_OFFBIG() {
        return _POSIX_V7_LPBIG_OFFBIG;
    }
    private static final int _V6_ILP32_OFF32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _V6_ILP32_OFF32 -1
     * }
     */
    public static int _V6_ILP32_OFF32() {
        return _V6_ILP32_OFF32;
    }
    private static final int _V6_ILP32_OFFBIG = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _V6_ILP32_OFFBIG -1
     * }
     */
    public static int _V6_ILP32_OFFBIG() {
        return _V6_ILP32_OFFBIG;
    }
    private static final int _V6_LP64_OFF64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _V6_LP64_OFF64 1
     * }
     */
    public static int _V6_LP64_OFF64() {
        return _V6_LP64_OFF64;
    }
    private static final int _V6_LPBIG_OFFBIG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _V6_LPBIG_OFFBIG 1
     * }
     */
    public static int _V6_LPBIG_OFFBIG() {
        return _V6_LPBIG_OFFBIG;
    }
    private static final int _XBS5_ILP32_OFF32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _XBS5_ILP32_OFF32 -1
     * }
     */
    public static int _XBS5_ILP32_OFF32() {
        return _XBS5_ILP32_OFF32;
    }
    private static final int _XBS5_ILP32_OFFBIG = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _XBS5_ILP32_OFFBIG -1
     * }
     */
    public static int _XBS5_ILP32_OFFBIG() {
        return _XBS5_ILP32_OFFBIG;
    }
    private static final int _XBS5_LP64_OFF64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _XBS5_LP64_OFF64 1
     * }
     */
    public static int _XBS5_LP64_OFF64() {
        return _XBS5_LP64_OFF64;
    }
    private static final int _XBS5_LPBIG_OFFBIG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _XBS5_LPBIG_OFFBIG 1
     * }
     */
    public static int _XBS5_LPBIG_OFFBIG() {
        return _XBS5_LPBIG_OFFBIG;
    }
    private static final int _XOPEN_CRYPT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _XOPEN_CRYPT 1
     * }
     */
    public static int _XOPEN_CRYPT() {
        return _XOPEN_CRYPT;
    }
    private static final int _XOPEN_ENH_I18N = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _XOPEN_ENH_I18N 1
     * }
     */
    public static int _XOPEN_ENH_I18N() {
        return _XOPEN_ENH_I18N;
    }
    private static final int _XOPEN_LEGACY = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _XOPEN_LEGACY -1
     * }
     */
    public static int _XOPEN_LEGACY() {
        return _XOPEN_LEGACY;
    }
    private static final int _XOPEN_REALTIME = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _XOPEN_REALTIME -1
     * }
     */
    public static int _XOPEN_REALTIME() {
        return _XOPEN_REALTIME;
    }
    private static final int _XOPEN_REALTIME_THREADS = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _XOPEN_REALTIME_THREADS -1
     * }
     */
    public static int _XOPEN_REALTIME_THREADS() {
        return _XOPEN_REALTIME_THREADS;
    }
    private static final int _XOPEN_SHM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _XOPEN_SHM 1
     * }
     */
    public static int _XOPEN_SHM() {
        return _XOPEN_SHM;
    }
    private static final int _XOPEN_STREAMS = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _XOPEN_STREAMS -1
     * }
     */
    public static int _XOPEN_STREAMS() {
        return _XOPEN_STREAMS;
    }
    private static final int _XOPEN_UNIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _XOPEN_UNIX 1
     * }
     */
    public static int _XOPEN_UNIX() {
        return _XOPEN_UNIX;
    }
    private static final int _SC_PAGE_SIZE = (int)29L;
    /**
     * {@snippet lang=c :
     * #define _SC_PAGE_SIZE 29
     * }
     */
    public static int _SC_PAGE_SIZE() {
        return _SC_PAGE_SIZE;
    }
    private static final long __DARWIN_NFDBITS = 32L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NFDBITS 32
     * }
     */
    public static long __DARWIN_NFDBITS() {
        return __DARWIN_NFDBITS;
    }
    private static final int FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FD_SETSIZE 1024
     * }
     */
    public static int FD_SETSIZE() {
        return FD_SETSIZE;
    }
}

